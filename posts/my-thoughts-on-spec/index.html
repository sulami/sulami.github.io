<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Thoughts on spec - sulami's blog</title>
        <link rel="stylesheet" type="text/css" href="../../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
        <link rel="manifest" href="../../images/site.webmanifest">
        <link rel="mask-icon" href="../../images/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="shortcut icon" href="../../images/favicon.ico">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-config" content="/images/browserconfig.xml">
        <meta name="theme-color" content="#5bbad5">
        <link href="../../atom.xml" type="application/atom+xml" rel="alternate" title="sulami's blog feed" />
    </head>
    <body>
        <input type="checkbox" id="lightswitch" />
        <div id="body">
        <div id="container">
        <div id="header">
            <div id="navigation">
                <label for="lightswitch" id="lightswitch-label">☀</label>
                ·
                <a href="../../">Home</a>
                ·
                <a href="../../archive/">Archive</a>
                ·
                <a href="../../atom.xml">Feed</a>
                ·
                <a href="../../pages/about/">About</a>
                ·
                <a href="../../pages/cv/">CV</a> <a href="../../pages/robin-schroer-cv.pdf">(PDF)</a>
                ·
                <a href="../../pages/uses-this/">Uses This</a>
                ·
                <a href="../../pages/frankenwm/">FrankenWM</a>
            </div>
        </div>

        <div id="content">
            <article>
                <h1>My Thoughts on spec</h1>
                <div class="info">
                    
                        Posted on July  1, 2019
                    
                    
                </div>

                <section>
            <p>In the beginning of this year I started a new job, and I am now fortunate enough to be writing <a href="https://clojure.org">Clojure</a> full-time. I believe that Clojure is a very well crafted language and enables developers like few others, but I have also some grievances to report. I want to prefix this by saying that I love Clojure despite its faults, and this is more of a constructive criticism piece than anything else.</p>
<h2 id="what-is-spec">What Is spec?</h2>
<p>What I want to discuss today is <a href="https://clojure.org/guides/spec"><code>clojure.spec</code></a>, the gradual typing solution shipped with Clojure since 1.9.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">I am of course aware that spec is officially in alpha, and that there is a second alpha version which might address some of my points here. But as I have not tried alpha 2 yet, and a lot of people are using alpha 1, we will be mostly looking at alpha 1 in this post. Still, feel free to contact me and tell me how alpha 2 will improve things.<br />
<br />
</span></span> In case you are not familiar with spec, here is a quick run-down of how it works:</p>
<p>Clojure is a dynamically typed language, meaning no (or very few) type annotations in the source code, unlike say Haskell or most curl-brace languages. While this removes a lot of visual clutter, and the language is designed in such a way that most functions can operate on most types for maximum flexibility, this also means that sometimes things break at run time due to type errors. To make dealing with types easier, spec allows you to place type definitions in strategic places, say at entry- and exit points of an app or a module to ensure that your idea of structure and type of your data still lines up with reality.</p>
<p>The benefit of this approach over static typing is that you can encapsulate parts of your software with type safety without having to deal with the encumbrance in the internals. You define a contract to the outside, but stay flexible in your implementation.</p>
<p>In practice it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> spec-demo
  (<span class="at">:require</span> [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.gen.alpha <span class="at">:as</span> gen]))

(s/def <span class="at">::name</span> <span class="kw">string?</span>)
(s/def <span class="at">::age</span> pos-int?)

(s/def <span class="at">::person</span>
  (s/keys <span class="at">:req-un</span> [<span class="at">::name</span>
                   <span class="at">::age</span>]))

(s/valid? <span class="at">::person</span>
          {<span class="at">:name</span> <span class="st">&quot;John&quot;</span>
           <span class="at">:age</span> <span class="dv">35</span>})
<span class="co">;; =&gt; true</span>

(s/explain <span class="at">::person</span>
           {<span class="at">:name</span> <span class="dv">35</span>})
<span class="co">;; =&gt; 35 - failed: string? in: [name] at: [:name] spec: :spec-demo/name</span>
<span class="co">;;    {:name 35} - failed: (contains? % :age) spec: :spec-demo/person</span>

(gen/generate
  (s/gen <span class="at">::person</span>))
<span class="co">;; =&gt; {:name &quot;3o311eSXA4Dm9cLkENIt3J5Gb&quot;, :age 3318}</span></code></pre></div>
<p>This snippet demonstrates creating a spec <code>person</code> which has sub-specs <code>name</code> and <code>age</code>, validates some data against the spec, explains why some data does not validate, and also generates some random data compliant with the spec. The last bit is incredibly useful for testing, as you can imagine. There are some more advanced features than what I have shown here, like specs for in- and output types of functions, but this is the gist of it.</p>
<h2 id="so-what-is-wrong-with-spec">So What Is Wrong with spec?</h2>
<h3 id="specs-as-macros">specs as Macros</h3>
<p>spec is implemented using macros, which are compile-time expansions, think template meta-programming in C++. This brings some limitations, which are especially noticeable in Clojure where, like in most other Lisps, code is treated as data and many parts of your software are introspectable at run time. specs are, once defined, not easy to extract data from.</p>
<p>Contrast this with <a href="https://github.com/plumatic/schema">schema</a>, a Clojure library which does essentially the same thing, and got started before spec. schema “schemas” are just hash maps, which are easily constructed and introspected at run time. schema has other problems, but the community seems to generally flock to spec as the officially blessed version.</p>
<p>The situation I have now repeatedly seen is one where I have a spec defining a specific representation of an entity, where for example one spec extends another one. A practical example here is when augmenting an entity with additional data, so that the output representation is a modified version of the input type.</p>
<p>You can define a spec as a superset of another spec, and only in that direction, using <code>s/or</code>, but at that point you are already stuck in the spec an cannot get the list of fields easily out of your specs. It would be nice to be able to define one spec in terms of flat data, which would also be available at run time. This would be incredibly helpful for use with something like <code>select-keys</code>.</p>
<p>There are ways of working around this, for example by using <code>eval</code>, or wrapping your spec macros in another layer of macros, but both of these are more hacks than solutions. <a href="https://github.com/clojure/spec-alpha2/wiki/Differences-from-spec.alpha">spec alpha 2</a> promises to solve this particular problem by separating symbolic specs from spec objects, the former being just flat data which can also be generated programmatically.</p>
<p>If spec alpha 2 works out the way I hope, this will be solved soon, and the documentation looks promising so far.</p>
<h3 id="namespacing">Namespacing</h3>
<p>spec is very intent on you using namespaces for your keywords, which in general is a good idea. Many developers, including myself, have been using the namespace of a key to give context about its use, for example <code>:person/name</code> is a different spec from <code>:company/name</code>. The problem with this is the overloading of namespaced keywords, which are an existing Clojure feature. These namespaces <code>person</code> and <code>company</code> do not actually exist, and I do not want to clutter all my keys with a long prefix like <code>:myapp.entities.person/name</code> to make it match a real namespace.</p>
<p>Now namespaced keywords can have any namespace, and the namespace does not actually have to exist for everything related to keywords to work well, except when it does. If you want to use a spec from another namespace, but <code>alias</code> that namespace to shorten it, you need to <code>require</code> that namespace, for which it needs to exist. As a workaround to this I have created “fake” namespaces in the past using a helper.</p>
<p>This actually leads me to another problem, which is the question of where to place specs in the first place. spec comes with a global, centralised registry for specs, which in alpha 1 you cannot opt out of. In theory this allows you to define/register your spec once in any place you like, and then access it from anywhere without having to know where it comes from or requiring it. This, while having the potential for being too opaque and magical, is actually a very good feature in my opinion. It is trivial to override specs when reloading them, and I have not experienced any issues with evaluation order yet. Due to specs referring to other specs by their name, you can define dependencies of a spec after the fact, and the system will pick them up accordingly.</p>
<p>My current solution for this is having a file &amp; namespace for every entity which can be required and aliased normally, the only problem with this being relationships between specs. As soon as one spec needs to include another spec, dependencies get muddled, so I have experimented with having a special namespace for specs which are shared across many other specs, but this is far from ideal. I wish there was a cleaner way to do this, especially leveraging the global registry.</p>
<h3 id="function-spec-definitions">Function spec Definitions</h3>
<p>I mentioned above that spec also allows instrumenting functions, but the semantics for this are a bit wonky in my opinion. See for yourself:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> double </span>[x]
  (<span class="kw">*</span> <span class="dv">2</span> x))

(s/fdef <span class="kw">double</span>
  <span class="at">:args</span> (s/cat <span class="at">:x</span> int?)
  <span class="at">:ret</span> int?
  <span class="at">:fn</span> #(<span class="kw">=</span> (<span class="at">:ret</span> %)
          (<span class="kw">-&gt;</span> % <span class="at">:args</span> <span class="at">:x</span> (<span class="kw">*</span> <span class="dv">2</span>))))</code></pre></div>
<p>This naive spec restricts in- and output types to integers, which is okay in this case. The <code>:fn</code> key describes the relationship between in- and output, and is in this case actually absurdly strict, but this is just an example. There are two issues I have with this:</p>
<p>First the <code>:fn</code> definition tends to be very elaborate and hard to understand at a glance. Even in this simple case, there is a lot going on in there, and the use of anonymous functions does not help it. In practice, this key is optional and I omit it almost always, because I cannot think of any formal assertions I want to make about the output which are also reasonably simple to encode. And if you want to make several separate assertions about the output, you almost cannot avoid breaking up the spec into pieces, at which point you have predicates which exist purely for spec.</p>
<p>The other issue I have is that this is decoupled from the actual function definition. In theory you can place the spec in a different namespace and refer to the function using its fully qualified name, and this is tempting, especially when looking at my previous point about these specs having the potential to be far more longer than the actual function definitions. But then your function exists conceptually in two places, and these two places have to be kept in sync. If you move, rename, or modify the function in almost any way, you have to modify the spec, too, but first you have to find the spec.</p>
<p>The problem I can see with this is that <code>:fn</code> can be used to make assertions about the functions, which can in almost all cases be made in unit tests as well. In fact, unit tests are meant for exactly this, asserting single assumptions about units at a time. The condition above could just as well be a test called <code>the result equals twice the input value</code>. Functions are usually only instrumented locally and/or during testing, as they incur non-negligible overhead, and I would argue that they do not provide significant assurances over unit tests.</p>
<p>I would much rather drop the <code>:fn</code> key, and include type declarations in the actual function definition, which is incidentally how schema works:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(s/defn <span class="kw">double</span> <span class="at">:-</span> s/Int
  [x <span class="at">:-</span> s/Int]
  (<span class="kw">*</span> <span class="dv">2</span> x))</code></pre></div>
<p>In the end, I am looking forward to the next iteration of spec, and hope it addresses as many issues as possible, and I am already blown away by how much better it is than alternatives available in other languages.</p>
                </section>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        </div>
        </div>
        <!-- Below is some JS, the only on this page. Things should be -->
        <!-- generally fine if you block it, but I'm adding notes so you -->
        <!-- can decide how you feel about each element. -->

        <!-- Privacy-aware analytics by https://www.goatcounter.com/ -->
        <!-- Stats are publicly available at https://sulami-blog.goatcounter.com/ -->
        <script data-goatcounter="https://sulami-blog.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

        <!-- Colour theme switcher -->
        <script>
          const themeSwitch = document.querySelector('#lightswitch');
          themeSwitch.checked = localStorage.getItem('switchedTheme') === 'true';

          themeSwitch.addEventListener('change', function (e) {
              if(e.currentTarget.checked === true) {
                  // Add item to localstorage
                  localStorage.setItem('switchedTheme', 'true');
              } else {
                  // Remove item if theme is switched back to normal
                  localStorage.removeItem('switchedTheme');
              }
          });
        </script>
    </body>
</html>
