<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>sulami's blog - My Thoughts About Go</title>
        <link rel="stylesheet" type="text/css" href="../../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
        <link rel="manifest" href="../../images/site.webmanifest">
        <link rel="mask-icon" href="../../images/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="shortcut icon" href="../../images/favicon.ico">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-config" content="/images/browserconfig.xml">
        <meta name="theme-color" content="#5bbad5">
        <link href="../../atom.xml" type="application/atom+xml" rel="alternate" title="sulami's blog feed" />
    </head>
    <body>
        <div id="header">
            <div id="navigation" style="margin-top: 2em">
                <a href="../../">Home</a>
                ·
                <a href="../../archive/">Archive</a>
                ·
                <a href="../../atom.xml">Feed</a>
                ·
                <a href="../../pages/about/">About</a>
                ·
                <a href="../../pages/cv/">CV</a> <a href="../../pages/cv.pdf">(PDF)</a>
                ·
                <a href="../../pages/uses-this/">Uses This</a>
                ·
                <a href="../../pages/frankenwm/">FrankenWM</a>
            </div>
        </div>

        <div id="content">
            <article>
                <h1>My Thoughts About Go</h1>
                <div class="info">
                    
                        Posted on February 18, 2015
                    
                    
                </div>

                <section>
            <p>After having used <a href="https://golang.org">Go</a> almost exclusively for the last two weeks, and for the first time seriously, I think I can give a general statement on what I think about it, analogous to <a href="%7Bfilename%7D/my-thoughts-about-d.md">D</a>.</p>
<p>Go has been in development at Google for a few years now, mainly by Robert Griesemer, Rob Pike and Ken Thompson, all quite big names. You can find specifics on <a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29">Wikipedia</a>, this post will primarily be my opinion. My first impression is, while D feels like a child of C and Python, or “C++ done right”, Go feels a lot more like raw C modernized. Like with D, I will give you a first look at something simple:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> main() {
    fmt.Println(<span class="st">&quot;Hello, World&quot;</span>)
}</code></pre></div>
<p>This all makes sense, right? The first line defines the package we are currently in. If this is a binary, no a library, this is always <code>main</code>. We then import <code>fmt</code>, the formatting standard library, enter <code>main()</code> and print out our implicitly typed string. Nothing too crazy, and most of the rest of the language looks similarly boring. That is actually a good thing™.</p>
<p>It is comparably stripped down and intentionally minimal. The big features Go brings are Goroutines and channels, both tools primarily used for concurrency. Goroutines are essentially lighter versions of threads, that can be used in a shell-pipe-style way to produce data-pipelines. Channels are managed FIFOs, used by Goroutines to communicate. All of this works very well and is incredibly simple, making Go a fantastic language for handling lots of IO, like load balancers or maybe database connections. It just scales well. A Goroutine example:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> work() {
    <span class="co">// do some work here</span>
}

<span class="kw">func</span> main() {
    <span class="co">// start 10 instances of work() in the background</span>
    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ {
        <span class="kw">go</span> work()
    }
    <span class="co">// Note: because main() exits here, work() will just die with it unless</span>
    <span class="co">// we wait for it</span>
}</code></pre></div>
<p>But unless you are dependent on this extreme scalability, Go might not be the right choice for you. There are no native objects like in Python, D or other modern languages. At least they do not look like it. Objects are C-style typedefs, often structs, and methods can be attached in the following way:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Vertex <span class="kw">struct</span> {
    X, Y <span class="dt">int</span>
}

<span class="kw">func</span> (v *Vertex) String() <span class="dt">string</span> {
    <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;Vertex: (%f, %f)&quot;</span>, v.X, v.Y)
}</code></pre></div>
<p>This is a Vertex method that takes no arguments and returns a string. Now, let us say the Vertex type should also implement an interface, because these exist in Go. It actually already does, it implements <code>fmt.Stringer</code>. Why, you ask? Because it defined the <code>String()</code> method, and interfaces are implemented implicitly as soon as all the methods they define are also defined by a type. This is one of the more extreme examples, where Go’s minimalism makes programming unnecessarily difficult.</p>
<p>On the other hand, Go comes with it’s own formatting tool, that enforces a standard coding style (but also tabs for indentation), package management (but without versioning, and the idea that you have to order your source in the so-called <code>$GOPATH</code>, which causes more work than one would imagine) and build tools. Makefiles are not really needed anymore, unless you try to do something special.</p>
<p>Go has this overall approach of “back to the roots, but better”, but also “do it our way”. The minimalism works in most scenarios quite well, interfaces are the only real problem you will encounter while writing the software itself, and maybe the completely missing inheritance. Things like the package management will drive you nuts, though. And the fact that because of the way Go handles certain things, like visibility (everything starting with a capital letter is “exported”), cause you to having to type a lot more than in other languages.</p>
<p><strong>TL;DR</strong> It feels boring, it feels old, and as a consequence overly laborious. As a general purpose language, I feel D does the job a lot better.</p>
                </section>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
