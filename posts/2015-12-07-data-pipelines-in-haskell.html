<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>sulami's blog - Data-Pipelines in Haskell</title>
        <link rel="stylesheet" type="text/css" href="../tufte/tufte.css" />
        <link rel="stylesheet" type="text/css" href="../css/solarized.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">/dev/urandom >> blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../pages/about.html">About</a>
                <a href="../pages/uses-this.html">Uses This</a>
                <a href="../pages/frankenwm.html">FrankenWM</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Data-Pipelines in Haskell</h1>

            <div class="info">
    
        Posted on December  7, 2015
    
    
</div>

<article>
    <section>
<p>Today I was writing some code in Golang and thought about why Haskell feels so much more powerful and expressive. Then I had a revelation. Haskell follows the UNIX philosophy, focussing on small functions that do exactly one thing (at least good Haskell code does so). It also makes these functions easily combinable without leading to syntastic noise like parenthesis-mountains. So I thought I might just write a post highlighting that, which is what you are currently reading.</p>
<p>We are going to start at the very basics, assuming you have little to no prior knowledge about Haskell. Haskell uses the <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Lambda_calculus_and_programming_languages">lambda calculus</a> and just whitespace to declare function arguments. So a function call looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">2</span> <span class="dv">3</span> <span class="co">-- 2 + 3 = 5</span></code></pre></div>
<p>If one of your arguments is actually the return value of another function call with arguments, you will need to add parentheses to tell your compiler which arguments belong to which function call, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> (add <span class="dv">1</span> <span class="dv">3</span>) <span class="co">-- 5 + (1 + 3) = 9</span></code></pre></div>
<p>Haskell functions often take arguments in an order so that the last argument is often the “main” one that is being used, which plays nicely with the <code>$</code> operator that is part of Prelude, the part of the Haskell standard library that gets imported automatically. <code>$</code> has the type <code>(a -&gt; b) -&gt; a -&gt; b</code> which looks sort of pointless, but in practise you can use it to build function pipelines without having to use parentheses.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> <span class="fu">$</span> add <span class="dv">1</span> <span class="dv">3</span> <span class="co">-- 5 + (1 + 3) = 9</span></code></pre></div>
<p>Note that in this code, <code>add 5</code> is a function that takes one argument, because one is already supplied. Its type is <code>Int -&gt; Int</code> compared to the original <code>Int -&gt; Int -&gt; Int</code>. And because Haskell has easy function composition using the <code>.</code> operator (<code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>), we can chain several functions in front of a <code>$</code>, building a reverse data pipeline like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> <span class="fu">.</span> subtract <span class="dv">3</span> <span class="fu">.</span> times <span class="dv">2</span> <span class="fu">$</span> add <span class="dv">1</span> <span class="dv">3</span> <span class="co">-- (((1 + 3) * 2) - 3) + 5 = 10</span></code></pre></div>
<p>As you can see, the data flows from the right side to the left. But coming back to the UNIX philosophy, there are also data pipelines, pipes. But in shell-pipes, data flows from left to right, which might be more intuitive. Note that in the last explanation I had to reverse the order because of the subtraction. We can fix this quite easily by defining a new operator, the “reverse <code>$</code>”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
x <span class="fu">&amp;</span> f <span class="fu">=</span> f x</code></pre></div>
<p>Note that the type annotation is the same as the one of <code>$</code> with just the arguments reversed. This specific operator is already defined in many community-made packages. It allows us to mimic the shell-pipe very closely:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">1</span> <span class="dv">3</span> <span class="fu">&amp;</span> times <span class="dv">2</span> <span class="fu">&amp;</span> subtract <span class="dv">3</span> <span class="fu">&amp;</span> add <span class="dv">5</span> <span class="co">-- (((1 + 3) * 2) - 3) + 5 = 10</span></code></pre></div>
<p>Now the explanation looks just like the code, and data flows from left to right, just like in the shell. These data pipelines make it easy to let small functions like <code>words</code>, <code>lines</code> or <code>map</code> work on data and pass the results to the next function, without having to worry about memory management, buffer overflows or even types, which makes this more robust than a shell-oneliner while being just as expressive and simple. Haskell’s laziness even allows for simple parallelism like the shell does when piping data, where functions/programs start working as soon as the first data reaches them.</p>
<p>This concept is so great, there is even a huge library to do this while doing I/O like when accessing files or communicating over a network, <a href="https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview">Conduit</a>.</p>
    </section>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
