<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>sulami's blog - A Fuzzy Finder in Haskell</title>
        <link rel="stylesheet" type="text/css" href="../../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
        <link rel="manifest" href="../../images/site.webmanifest">
        <link rel="mask-icon" href="../../images/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="shortcut icon" href="../../images/favicon.ico">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-config" content="/images/browserconfig.xml">
        <meta name="theme-color" content="#5bbad5">
        <link href="../../atom.xml" type="application/atom+xml" rel="alternate" title="sulami's blog feed" />
    </head>
    <body>
        <input type="checkbox" id="lightswitch" />
        <div id="body">
        <div id="container">
        <div id="header">
            <div id="navigation">
                <label for="lightswitch" id="lightswitch-label">☀</label>
                ·
                <a href="../../">Home</a>
                ·
                <a href="../../archive/">Archive</a>
                ·
                <a href="../../atom.xml">Feed</a>
                ·
                <a href="../../pages/about/">About</a>
                ·
                <a href="../../pages/cv/">CV</a> <a href="../../pages/robin-schroer-cv.pdf">(PDF)</a>
                ·
                <a href="../../pages/uses-this/">Uses This</a>
                ·
                <a href="../../pages/frankenwm/">FrankenWM</a>
            </div>
        </div>

        <div id="content">
            <article>
                <h1>A Fuzzy Finder in Haskell</h1>
                <div class="info">
                    
                        Posted on June 24, 2016
                    
                    
                </div>

                <section>
            <p>This is a response to <em><a href="http://blog.amjith.com/fuzzyfinder-in-10-lines-of-python">FuzzyFinder - in 10 lines of Python</a></em>, which was posted to reddit yesterday.</p>
<p>Following the blogpost linked above, I decided to write my own fuzzy finder in Haskell, because that is the language I am currently learning, and think has great potential. It is also a more interesting <a href="https://github.com/sulami/spielwiese/tree/master/hEuler">exercise</a> than <a href="https://projecteuler.net/">Project Euler</a>.</p>
<p>Just in case you have not read the original post and do not know what a fuzzy finder is, it is a mechanism to filter and sort a list of strings by searching for substrings. It is often used in text editors like vim or Sublime Text, where you can just type in /“accmanba”/ and they will open up <code>account_management_backend.py</code> for you. As you can see, it makes switching between more than two files in a project much easier and faster.</p>
<p>Amjith wrote his finder using regular expressions, which are part of the Python standard library and can be compiled to be reasonably fast very easily. Sadly, Haskell has no implementation of regular expressions in its standard library, and I did not want to use third-party ones just for this. But as it turns out, we do not even need them, because the task is so simple and Haskell’s string manipulation capabilities are incredible, so that we can solve this by implementing the search algorithm ourselves and still achieve good performance.</p>
<p>So, let us get on to some actual code. The most interesting part here is the matching algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">partOf ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Int</span>)
partOf _ []     r <span class="fu">=</span> (<span class="dt">False</span>, <span class="dv">0</span>)
partOf c (x<span class="fu">:</span>xs) r <span class="fu">|</span>    c <span class="fu">==</span> x <span class="fu">=</span> (<span class="dt">True</span>, r <span class="fu">+</span> <span class="dv">1</span>)
                  <span class="fu">|</span> otherwise <span class="fu">=</span> partOf c xs <span class="fu">$</span> r <span class="fu">+</span> <span class="dv">1</span>

<span class="ot">match ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> ([<span class="dt">Char</span>], [<span class="dt">Char</span>]) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, [<span class="dt">Int</span>])
match i s <span class="fu">=</span> match' i (snd s) []
  <span class="kw">where</span>
<span class="ot">    match' ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, [<span class="dt">Int</span>])
    match' []     _ r <span class="fu">=</span> (<span class="dt">True</span>, r)
    match' (x<span class="fu">:</span>xs) s r <span class="fu">|</span> fst check <span class="fu">=</span> match' xs (drop used s) <span class="fu">$</span> r <span class="fu">++</span> [used]
                      <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">False</span>, r)
      <span class="kw">where</span>
        used <span class="fu">=</span> snd check
        check <span class="fu">=</span> partOf x s <span class="dv">0</span></code></pre></div>
<p>I know this is not really optimized for readability and especially not if you do not know Haskell, but stay with me, it is quite simple. Before we compare the input, we map all the possible solutions to lowercase and store them in a tuple like <code>(&quot;String&quot;, &quot;string&quot;)</code>. This way, we can compare against the lowercase version and return the properly capitalized one later on. All we do then is check for each possible solution if each character of the input string appears in order in the solution. If so, we add it to a list along with some data, specifically the position of the first match and the distance between the first and last matched character in the solution. This is the same Amjith did for sorting. All this data gets returned in a big list of tuples with both versions of the solutions and the match data. It is not pretty, but it works.</p>
<p>The one function the module actually exports is <code>fuzzyFinder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fuzzyFinder ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]]
fuzzyFinder input list <span class="fu">=</span> map fst <span class="fu">.</span> map snd <span class="fu">$</span> sort combo
  <span class="kw">where</span>
    combo <span class="fu">=</span> zip (zip ((map sum <span class="fu">.</span> map tail) scores) (map head scores)) matches
    scores <span class="fu">=</span> map snd <span class="fu">$</span> map (match input) matches
    matches <span class="fu">=</span> filter (fst <span class="fu">.</span> match input) <span class="fu">$</span> prepInput list</code></pre></div>
<p>All this function does is build the tuple list with the lowercase versions, toss it into the match function and filter out the correct versions from the matches that came back, ordering them by the match data in the same way Amjith did it. There are just a couple of extra lines that I omitted here because they are not important, but you can find the complete source on <a href="https://github.com/sulami/spielwiese/tree/master/hFuzzyFinder">Github</a>.</p>
<p>Now you might say, this cannot be fast, it is iterating through all this stuff and with big enough input it will take forever to present results. Let me show you this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readL ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
readL a <span class="fu">=</span> read <span class="fu">$</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot;]&quot;</span>

main <span class="fu">=</span> <span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
          <span class="kw">if</span> length args <span class="fu">==</span> <span class="dv">2</span> <span class="kw">then</span> <span class="kw">do</span>
            list <span class="ot">&lt;-</span> readFile <span class="fu">$</span> args <span class="fu">!!</span> <span class="dv">1</span>
            print <span class="fu">$</span> fuzzyFinder (args <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">$</span> readL list
          <span class="kw">else</span>
            putStrLn <span class="st">&quot;Wrong number of args&quot;</span></code></pre></div>
<p>This is a small program that takes two arguments, the query string and a file path of a list of possible solutions and performs the actions outlined above. Using a 2.2GHz Core 2 Duo, because I am using my laptop, and a 46K list containing over 5000 words (Thanks, Project Euler), this happens:</p>
<pre class="example"><code>λ time ./interactive roro ../hEuler/022.input
[&quot;ROBERTO&quot;,&quot;RODRIGO&quot;,&quot;ROSARIO&quot;,&quot;GREGORIO&quot;,&quot;RIGOBERTO&quot;]
./interactive roro ../hEuler/022.input  0.08s user 0.00s system 96% cpu 0.079 total
</code></pre>
<p>The execution time goes up to 0.09 seconds when printing out really many names, but that is caused by the fact that we have to print out 100 lines or more to the console, which also takes time. But in my opinion, this is more than fast enough for auto-completion, which is the main use for fuzzy finders.</p>
<p>So overall, I am really happy with how this turned out. I was able to write this on one morning despite still learning the language. It is reasonably concise despite the fact that I did not use regular expressions but searched the strings manually and also quite fast.</p>
                </section>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        </div>
        </div>
        <script>
          const themeSwitch = document.querySelector('#lightswitch');
          themeSwitch.checked = localStorage.getItem('switchedTheme') === 'true';

          themeSwitch.addEventListener('change', function (e) {
              if(e.currentTarget.checked === true) {
                  // Add item to localstorage
                  localStorage.setItem('switchedTheme', 'true');
              } else {
                  // Remove item if theme is switched back to normal
                  localStorage.removeItem('switchedTheme');
              }
          });
        </script>
    </body>
</html>
