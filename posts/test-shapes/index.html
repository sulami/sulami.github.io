<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>The Shape of Tests - sulami's blog</title>
        <link rel="stylesheet" type="text/css" href="../../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
        <link rel="manifest" href="../../images/site.webmanifest">
        <link rel="mask-icon" href="../../images/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="shortcut icon" href="../../images/favicon.ico">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-config" content="/images/browserconfig.xml">
        <meta name="theme-color" content="#5bbad5">
        <link href="../../atom.xml" type="application/atom+xml" rel="alternate" title="sulami's blog feed" />
    </head>
    <body>
        <input type="checkbox" id="lightswitch" />
        <div id="body">
        <div id="container">
        <div id="header">
            <div id="navigation">
                <label for="lightswitch" id="lightswitch-label">☀</label>
                ·
                <a href="../../">Home</a>
                ·
                <a href="../../posts/">Archive</a>
                ·
                <a href="../../atom.xml">Feed</a>
                ·
                <a href="../../pages/about/">About</a>
                ·
                <a href="../../pages/cv/">CV</a> <a href="../../pages/robin-schroer-cv.pdf">(PDF)</a>
                ·
                <a href="../../pages/uses-this/">Uses This</a>
                ·
                <a href="../../pages/frankenwm/">FrankenWM</a>
            </div>
        </div>

        <div id="content">
            <article>
                <h1>The Shape of Tests</h1>
                <div class="info">
                    
                        Posted on March  3, 2021
                    
                    
                </div>

                <section>
            <p>Many tests for an operation iterate over a mapping of different inputs to expected outcomes. By looking at the tests for a single operation as the same test with different inputs and output expectations, we can start to question how we should model those tests.</p>
<h2 id="tests-as-matrices">Tests as Matrices</h2>
<p>By simply enumerating every possible combination of input values, we can construct a matrix with as many dimensions as inputs. We can then define the expected result for each set of inputs, and write a generalised test function:</p>
<blockquote>
<p>∀ input∈{(a, b, …, n) | a∈A, b∈B, …, n∈N} f(input)</p>
</blockquote>
<p>The number of possible test cases is thus:</p>
<blockquote>
<p>|<em>i</em><em>n</em><em>p</em><em>u</em><em>t</em><em>s</em>| = |A × B × ⋯ × N|</p>
</blockquote>
<p>As soon as our operation accepts an input that has more than a few possible values, that is any kind of number,<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">With more than 8 bits at least. One could reasonably enumerate 256 different inputs for an operation, for correctness proven by test.<br />
<br />
</span></span> string, or complex data structure, enumerating every possible input combination becomes impractical. Instead we can resort to groupings of values via properties.</p>
<p>This is a test matrix for division which uses properties instead of values, with the rows being dividends, and the columns divisors:</p>
<table>
<thead>
<tr class="header">
<th>÷</th>
<th>Positive</th>
<th>Zero</th>
<th>Negative</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td>Positive</td>
<td>undefined</td>
<td>Negative</td>
</tr>
<tr class="even">
<td>Zero</td>
<td>Zero</td>
<td>undefined</td>
<td>Zero</td>
</tr>
<tr class="odd">
<td>Negative</td>
<td>Negative</td>
<td>undefined</td>
<td>Positive</td>
</tr>
</tbody>
</table>
<p>Matrices like this are necessarily exhaustive,<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">Unless we designate a special result to mean “<em>do not test this set of inputs</em>”.<br />
<br />
</span></span> and force us to think about the result for every possible combination of the input values we have included.</p>
<p>This is an implementation of the same property matrix in Clojure:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> division-matrix-test
  (<span class="at">:require</span> [clojure.<span class="kw">test</span> <span class="at">:refer</span> [<span class="bu">deftest</span><span class="fu"> is </span><span class="kw">testing</span>]]
            [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.gen.alpha <span class="at">:as</span> gen]))

(<span class="bu">defn</span><span class="fu"> safe-divide</span>
  <span class="st">&quot;2-arity `/`, but returns `nil` on division by zero.&quot;</span>
  [dividend divisor]
  (<span class="kw">try</span>
    (<span class="kw">/</span> dividend divisor)
    (<span class="kw">catch</span> ArithmeticException _
      nil)))

(<span class="bu">defmacro</span><span class="fu"> test-matrix</span>
  <span class="st">&quot;Generates tests for a two-dimensional test matrix.&quot;</span>
  [test-fn matrix]
  (<span class="kw">let</span> [columns (<span class="kw">rest</span> (<span class="kw">first</span> matrix))
        rows (<span class="kw">map</span> <span class="kw">first</span> (<span class="kw">rest</span> matrix))
        combinations (<span class="kw">for</span> [[row idy] (<span class="kw">map</span> #(<span class="kw">vector</span> %<span class="dv">1</span> %<span class="dv">2</span>) rows (<span class="kw">range</span>))
                           [col idx] (<span class="kw">map</span> #(<span class="kw">vector</span> %<span class="dv">1</span> %<span class="dv">2</span>) columns (<span class="kw">range</span>))]
                       [row col (<span class="kw">-&gt;</span> matrix
                                    (<span class="kw">nth</span> (<span class="kw">inc</span> idy))
                                    (<span class="kw">nth</span> (<span class="kw">inc</span> idx)))])]
    `(<span class="kw">doseq</span> [combination# [<span class="at">~@combinations]]</span>
       (<span class="kw">apply</span> <span class="at">~test-fn</span> combination#))))

(<span class="bu">deftest</span><span class="fu"> safe-division-test</span>
  (<span class="kw">let</span> [gen-input
        (<span class="kw">fn</span> [kind]
          (<span class="kw">case</span> kind
            <span class="at">:pos</span> (gen/generate (s/gen pos-int?))
            <span class="at">:neg</span> (gen/generate (s/gen neg-int?))
            <span class="at">:zero</span> <span class="dv">0</span>))]

    (test-matrix

     (<span class="kw">fn</span> [x y result-pred]
       (<span class="kw">let</span> [dividend (gen-input x)
             divisor (gen-input y)]
         (<span class="kw">is</span> (result-pred (safe-divide dividend divisor))
             (<span class="kw">format</span> <span class="st">&quot;Failed with: %s / %s&quot;</span> dividend divisor))))

     [[nil    <span class="at">:pos</span>   <span class="at">:zero</span>  <span class="at">:neg</span> ]
      [<span class="at">:pos</span>   <span class="kw">pos?</span>   <span class="kw">nil?</span>   <span class="kw">neg?</span> ]
      [<span class="at">:zero</span>  <span class="kw">zero?</span>  <span class="kw">nil?</span>   <span class="kw">zero?</span>]
      [<span class="at">:neg</span>   <span class="kw">neg?</span>   <span class="kw">nil?</span>   <span class="kw">pos?</span> ]])))</code></pre></div>
<p>In this case we are testing a safe variant of the division function <code>/</code>, which returns <code>nil</code> if the divisor is zero. This simplifies the testing process, because we do not have to include any exception catching logic in our test function, or invent a notation to mean <em>this set of inputs should result in a thrown exception</em>.</p>
<p>It is worth noting that such a direct interpretation of a matrix is only possible in a language as malleable as Clojure. In other languages, we might have to resort to enumerating a set of <code>(dividend
divisor result)</code> tuples, losing the guarantee of covering all possible combinations.</p>
<p>But even in Clojure, more than two dimensions in this matrix will quickly become unwieldy and hard to follow, and a tuple-based approach would scale better to larger numbers of input parameters.</p>
<h2 id="tests-as-trees">Tests as Trees</h2>
<p>Another way we could structure our tests is as a tree. A tree does not have to be exhaustive the same way a matrix has to be.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">Again, assuming we are using a matrix based approach, rather than enumerating combinations manually.<br />
<br />
</span></span> We can omit certain combinations of inputs by pruning their branches. In this way we are implying that if a single input has a given value, it defines the result regardless of the other inputs’ values.</p>
<p>In the division example all branches with a divisor of zero could be collapsed into a single case, as the dividend does not matter in this case. This only works if the first level of branching describes the divisor, and the dividends are on the second level.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> division-tree-test
  (<span class="at">:require</span> [clojure.<span class="kw">test</span> <span class="at">:refer</span> [<span class="kw">are</span> <span class="bu">deftest</span><span class="fu"> testing</span>]]
            [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.gen.alpha <span class="at">:as</span> gen]))

(<span class="bu">deftest</span><span class="fu"> safe-division-test</span>

  (<span class="kw">testing</span> <span class="st">&quot;with a positive divisor&quot;</span>
    (<span class="kw">let</span> [divisor (gen/generate (s/gen pos-int?))]

      (<span class="kw">testing</span> <span class="st">&quot;and a positive dividend&quot;</span>
        (<span class="kw">let</span> [dividend (gen/generate (s/gen pos-int?))]
          (<span class="kw">is</span> (<span class="kw">pos?</span> (safe-divide dividend divisor)))))

      (<span class="kw">testing</span> <span class="st">&quot;and a zero dividend&quot;</span>
        (<span class="kw">let</span> [dividend <span class="dv">0</span>]
          (<span class="kw">is</span> (<span class="kw">zero?</span> (safe-divide dividend divisor)))))

      (<span class="kw">testing</span> <span class="st">&quot;and a negative dividend&quot;</span>
        (<span class="kw">let</span> [dividend (gen/generate (s/gen neg-int?))]
          (<span class="kw">is</span> (<span class="kw">neg?</span> (safe-divide dividend divisor)))))))

  (<span class="kw">testing</span> <span class="st">&quot;with a divisor of zero&quot;</span>
    (<span class="kw">let</span> [dividend (gen/generate (s/gen int?))]
      (<span class="kw">is</span> (<span class="kw">nil?</span> (safe-divide dividend <span class="dv">0</span>)))))

  (<span class="kw">testing</span> <span class="st">&quot;with a negative divisor&quot;</span>
    (<span class="kw">let</span> [divisor (gen/generate (s/gen neg-int?))]

      (<span class="kw">testing</span> <span class="st">&quot;and a positive dividend&quot;</span>
        (<span class="kw">let</span> [dividend (gen/generate (s/gen pos-int?))]
          (<span class="kw">is</span> (<span class="kw">neg?</span> (safe-divide dividend divisor)))))

      (<span class="kw">testing</span> <span class="st">&quot;and a zero dividend&quot;</span>
        (<span class="kw">let</span> [dividend <span class="dv">0</span>]
          (<span class="kw">is</span> (<span class="kw">zero?</span> (safe-divide dividend divisor)))))

      (<span class="kw">testing</span> <span class="st">&quot;and a negative dividend&quot;</span>
        (<span class="kw">let</span> [dividend (gen/generate (s/gen neg-int?))]
          (<span class="kw">is</span> (<span class="kw">pos?</span> (safe-divide dividend divisor))))))))</code></pre></div>
<p>This might look more verbose, but in exchange we get a unique label for every tree branch,<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">We can also make use of useful property of <code>clojure.test</code>: if a test fails, it will traverse the <code>testing</code> statements upwards and concatenate the names, providing us with the path of the failed test. For example “<em>with a negative divisor and a zero dividend</em>”.<br />
<br />
</span></span> which can improve readability. The nesting also naturally lends itself to lexical scoping, so we only have the values in scope which apply on a given branch.</p>
<p>A key advantage of the tree structure is flexibility. If one of the branches requires special code, we can confine it to that branch, avoiding complicating the remaining branches more than necessary.</p>
<p>Trees also scale better with larger numbers of inputs or options for inputs. A tree might grow overly wide or deep, but we can split it if that becomes a problem.</p>
<p>There is a downside to omitting branches though. If we change our <code>safe-divide</code> function to return different results depending on the dividend when the divisor is zero, our tests might still pass, depending on the specific inputs used, but we will lose test coverage for certain code paths. We have chosen to not test certain input combinations, and we need to be aware of this omission when we are changing the code under test.</p>
<h2 id="tests-as-definitions">Tests as Definitions</h2>
<p>Considering the formula describing the generalised test function above, we could also consider translating this directly into code. This can work, but only if we can test results without re-implementing large parts of the code under test, otherwise we are overly coupling the tests to the code. In the division case, we can decide the sign of the result<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><span class="sidenote">Or the existence, for that matter.<br />
<br />
</span></span> based on the signs of the inputs.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> division-spec-test
  (<span class="at">:require</span> [clojure.<span class="kw">test</span> <span class="at">:refer</span> [<span class="bu">deftest</span><span class="fu"> is</span>]]
            [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.<span class="kw">test</span>.alpha <span class="at">:as</span> stest]))

(<span class="bu">defn-</span><span class="fu"> check-safe-divide-result </span>[{{<span class="at">:keys</span> [dividend divisor]} <span class="at">:args</span>
                                  ret <span class="at">:ret</span>}]
  (<span class="kw">cond</span>
    (<span class="kw">zero?</span> divisor) (<span class="kw">nil?</span> ret)

    (<span class="kw">zero?</span> dividend) (<span class="kw">zero?</span> ret)

    (<span class="kw">or</span> (<span class="kw">and</span> (<span class="kw">pos?</span> dividend) (<span class="kw">pos?</span> divisor))
        (<span class="kw">and</span> (<span class="kw">neg?</span> dividend) (<span class="kw">neg?</span> divisor)))
    (<span class="kw">pos?</span> ret)

    <span class="at">:else</span> (<span class="kw">neg?</span> ret)))

(s/fdef safe-divide
  <span class="at">:args</span> (s/cat <span class="at">:dividend</span> <span class="kw">number?</span>
               <span class="at">:divisor</span> <span class="kw">number?</span>)
  <span class="at">:ret</span> (s/nilable <span class="kw">number?</span>)
  <span class="at">:fn</span> check-safe-divide-result)

(<span class="bu">deftest</span><span class="fu"> safe-divide-spec-test</span>
  (<span class="kw">let</span> [check-result (stest/check `safe-divide)]
    (<span class="kw">is</span> (<span class="kw">not</span> check-result)
        (<span class="kw">format</span> <span class="st">&quot;Failed with: %s&quot;</span>
                (<span class="kw">-&gt;</span> check-result
                    <span class="kw">first</span>
                    stest/abbrev-result
                    <span class="at">:failure</span>
                    <span class="at">::stest</span>/val)))))</code></pre></div>
<p>This solution is specific to Clojure, though many other languages have property based testing tools that work similarly.</p>
<p>By adding a spec to our function, we can run a large number of different inputs against our function, and assert a property about the result based on the inputs. It will even shrink the inputs to find the simplest set of inputs to trigger a spec failure.</p>
<p>This means we do not have a programmer writing a matrix or a tree by hand anymore, which has some advantages. The main one being that a programmer might not consider all possible inputs.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">Fail in safe-divide-spec-test
Failed with: {<span class="at">:args</span> {<span class="at">:dividend</span> ##NaN, <span class="at">:divisor</span> <span class="dv">0</span>}, <span class="at">:ret</span> ##NaN}

Fail in safe-divide-spec-test
Failed with: {<span class="at">:args</span> {<span class="at">:dividend</span> <span class="dv">1</span>, <span class="at">:divisor</span> ##Inf}, <span class="at">:ret</span> <span class="fl">0.0</span>}

Fail in safe-divide-spec-test
Failed with: {<span class="at">:args</span> {<span class="at">:dividend</span> <span class="fl">6.812735744013041E-108</span>, <span class="at">:divisor</span> <span class="fl">2.7578261315509936E216</span>}, <span class="at">:ret</span> <span class="fl">0.0</span>}</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>The optimal shape of a test depends mainly on the structure of the inputs to the operation we are testing, as well as its nature.</p>
<p>For pure functions which we expect to use widely and change rarely, property-based testing can be desirable to avoid unintended consequences. There is also a certain speed requirement for test shrinking to work effectively.</p>
<p>Operations with a small number of possible inputs can also be tested via test matrices, which have fewer limitations, but do not guarantee correctness, as only the programmer can assert the completeness of the matrix. They are easy to extend with additional values for parameters, but harder to extend with additional values. Their declarative nature can be useful for documentation purposes.</p>
<p>At the other end of the spectrum, tree-shaped tests are the most flexible, and scale best for larger operations with many inputs. If different branches require fundamentally different setup, test trees can isolate that complexity to where it is required. They also require the most care to keep tidy, and have a tendency to sprawl if unsupervised.</p>
                </section>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        </div>
        </div>
        <!-- Below is some JS, the only on this page. Things should be -->
        <!-- generally fine if you block it, but I'm adding notes so you -->
        <!-- can decide how you feel about each element. -->

        <!-- Privacy-aware analytics by https://www.goatcounter.com/ -->
        <!-- Stats are publicly available at https://sulami-blog.goatcounter.com/ -->
        <script data-goatcounter="https://sulami-blog.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script>

        <!-- Colour theme switcher -->
        <script>
          const themeSwitch = document.querySelector('#lightswitch');
          themeSwitch.checked = localStorage.getItem('switchedTheme') === 'true';

          themeSwitch.addEventListener('change', function (e) {
              if(e.currentTarget.checked === true) {
                  // Add item to localstorage
                  localStorage.setItem('switchedTheme', 'true');
              } else {
                  // Remove item if theme is switched back to normal
                  localStorage.removeItem('switchedTheme');
              }
          });
        </script>
    </body>
</html>
