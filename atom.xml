<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>sulami's blog</title>
    <link href="https://sulami.github.io/atom.xml" rel="self" />
    <link href="https://sulami.github.io" />
    <id>https://sulami.github.io/atom.xml</id>
    <author>
        <name>Robin Schroer</name>
        <email>sulami@peerwire.org</email>
    </author>
    <updated>2019-08-30T00:00:00Z</updated>
    <entry>
    <title>Why I like Clojure</title>
    <link href="https://sulami.github.io/posts/why-i-like-clojure/index.html" />
    <id>https://sulami.github.io/posts/why-i-like-clojure/index.html</id>
    <published>2019-08-30T00:00:00Z</published>
    <updated>2019-08-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is somewhat of a response to Uncle Bob’s <a href="http://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html">post of similar nature</a>, which I would say has gotten a mixed to positive reception. I had planned a similar post a week or two before the release of his, but archived the idea upon reading his post. But after having read it over a couple of times I have now decided that I still have something meaningful to write. What follows are the purely subjective reasons for which <em>I</em> enjoy using Clojure. Some have criticised Bob for being very absolute and not giving up any screen estate for more nuanced viewpoints, something I will try to avoid.</p>
<h2 id="lisp">Lisp</h2>
<p>There is not much to say about this that has not already been said. The homoiconicity, meaning code can be represented as a data structure inside the same language, extensibility through macros which can modify both the evaluation order as well as the very syntax to the point where <a href="https://docs.racket-lang.org/scribble/getting-started.html">it looks more like LaTeX than Lisp</a>.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Racket is actually a great example of the flexibility of Lisp. A language designed to build other languages in it, call it a meta-language. Even package import can be wrapped up in a “language” trivially, meaning that you can essentially write a tiny DSL for every project. Not saying that is necessarily a good idea, but you can.<br />
<br />
</span></span></p>
<p>This also means that you are not stuck with a paradigm. While OO seems to be out, and FP the new hotness, Lisp can do them all, and historically often did before anyone else. Bob mentions dynamic typing in his signature retorts to (I am guessing) fictional counter-arguments, and he is right to mention <a href="https://clojure.org/guides/spec"><code>clojure.spec</code></a>, a library for gradual typing (omitting <a href="https://github.com/plumatic/schema"><code>schema</code></a>, an alternative). Racket has a <a href="https://docs.racket-lang.org/ts-guide/quick.html">fully typed variant</a>, there is something that is basically <a href="https://shen-language.github.io">Haskell in a Lisp-bun</a>, and let us not forget that there is actually <a href="https://github.com/clojure/core.typed">Typed Clojure</a>, with static type checking and all.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">There are some issues with it, namely that the coverage is not all that great, but it exists and works, meaning if you really <em>need</em> static types, you can get them.<br />
<br />
</span></span></p>
<p>Being able to generate code without being stuck on a “dumb” level by generating strings and passing them into <code>eval</code> like for example in Python allows for sane hyper-dynamic programming, where the program adapts itself to the conditions. Being able to read and write code in a safe manner enables extremely powerful tooling in the Lisp world. Linters are very smart, because <a href="https://github.com/xsc/rewrite-clj">reading code into a data structure is trivial</a>, usually a one-liner, and there are many more tools to automatically rewrite and refactor code than for other languages.</p>
<p>Now I do not want to discount the <a href="http://winestockwebdesign.com/Essays/Lisp_Curse.html">Lisp Curse</a>, it is a real thing, and one of the reasons that while Lisp has stuck around for over half a century, it has not made it into the mainstream. The other main factor probably being the performance problems due to the gap between software and hardware architecture.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">There were Lisp machines, which had hardware tailored towards running Lisp, but they never took off either.<br />
<br />
</span></span> But with the advent of the internet, ecosystems like GitHub, and hardware that is fast enough that we consider running basically full web browsers for half of our applications<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Looking at you, Slack.<br />
<br />
</span></span>, I think that these issues have become surmountable.</p>
<p>I do not think I need to mention how incredibly useful the REPL and hot-loading code into a running system are?</p>
<h2 id="hosted">Hosted</h2>
<p>Clojure is explicitly designed as a hosted language, which I think was a very good move. If you are writing a new language today, it might be better than the established ones, but the cost of leaving an existing ecosystem of libraries and Stack Overflow answers just because the new language is 5% nicer is not a trade off many people will want to make. Clojure being hosted and having excellent interoperability with its host platform means it can benefit from existing ecosystem, let alone platform implementations.<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">Do you really want to implement your runtime for FreeBSD on a smart toaster oven? Raspberry Pis are non x86, BSD is not Linux, and who knows what is up with Windows. This matrix is growing quickly.<br />
<br />
</span></span></p>
<p>While the primary platform is the JVM, superbly uncool but stable and relatively performant, there is a CLR (.NET) version which is “almost even on features” thanks to Alex Miller, as well as a very mature JavaScript version in the shape of ClojureScript. The JVM (and to some extent the CLR) have excellent support by big software vendors, if you buy some kind of software with an API, chances are there is a Java SDK which you can use easily from your Clojure code. The JavaScript ecosystem is the largest in numbers<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">In part due to left-pad-like five-line-packages, but still.<br />
<br />
</span></span>, and includes Electron and React-Native, both of which can be used with some, but not unreasonable, effort from ClojureScript code. One of the newest additions has been GraalVM, which while not 100% feature-complete yet, already allows compilation to native static binaries of many Clojure programs<span><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span class="sidenote"><a href="https://github.com/kkinnear/zprint">Zprint</a> is one of those CLI tools that takes advantage of the reduced startup time.<br />
<br />
</span></span>, running without the JVM at all, and doing away with the dreaded multi-second startup time.<span><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span class="sidenote">I am planning to write a piece about GraalVM some time later this year.<br />
<br />
</span></span></p>
<p>The platform split could have been one of the big, curse-like problems for Clojure, but there is Clojure Common, used by many popular libraries, which allows you to write platform-independent code by using conditional branching for all platform-specific code.</p>
<h2 id="community">Community</h2>
<p>Despite all the positive points I mentioned, Clojure is still a niche language, and in some way that is good as well. Sure, finding jobs is harder<span><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span class="sidenote">Large companies like Walmart and CircleCI (my employer) are Clojure shops, so it is far less obscure than one might think.<br />
<br />
</span></span>, but not impossible. Clojure developers, like for example Haskell or Rust ones, tend to be more experienced, as it is not a typical first language, and requires a certain interest in the craft. Many Clojure developers have written widely used tools and libraries, not just in Clojure, but also for example for Emacs, which is understandably quite popular with Clojurists.</p>
<p>Rich Hickey himself, the BDFL of Clojure, is someone with decades of industry experience and a desire to get it right. I think he is doing a pretty good job. While there are some small inconsistencies in places, the bulk of the language, and all the important parts are very well thought out.<span><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span class="sidenote">We can also see right now how <code>clojure.spec</code> is being adapted after community feedback to the first alpha version, which has been available for about 1½ years.<br />
<br />
</span></span> Clojure is a very stable language, which means that smaller problems will stick around for a while, but also means you can trust that your code will not break every time up update your dependencies.</p>
<p>In the end, it comes down to enjoyment. I enjoy working with Clojure. I feel like there is a lot to learn, and the language is inviting me to explore beyond the current possibilities of software development. I feel good about the elegant and concise solutions<span><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span class="sidenote">concise ≠ obtuse<br />
<br />
</span></span> I can come up with. It has changed the way I think, in a good way.</p>]]></summary>
</entry>
<entry>
    <title>My Thoughts on spec</title>
    <link href="https://sulami.github.io/posts/my-thoughts-on-spec/index.html" />
    <id>https://sulami.github.io/posts/my-thoughts-on-spec/index.html</id>
    <published>2019-07-01T00:00:00Z</published>
    <updated>2019-07-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the beginning of this year I started a new job, and I am now fortunate enough to be writing <a href="https://clojure.org">Clojure</a> full-time. I believe that Clojure is a very well crafted language and enables developers like few others, but I have also some grievances to report. I want to prefix this by saying that I love Clojure despite its faults, and this is more of a constructive criticism piece than anything else.</p>
<h2 id="what-is-spec">What Is spec?</h2>
<p>What I want to discuss today is <a href="https://clojure.org/guides/spec"><code>clojure.spec</code></a>, the gradual typing solution shipped with Clojure since 1.9.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I am of course aware that spec is officially in alpha, and that there is a second alpha version which might address some of my points here. But as I have not tried alpha 2 yet, and a lot of people are using alpha 1, we will be mostly looking at alpha 1 in this post. Still, feel free to contact me and tell me how alpha 2 will improve things.<br />
<br />
</span></span> In case you are not familiar with spec, here is a quick run-down of how it works:</p>
<p>Clojure is a dynamically typed language, meaning no (or very few) type annotations in the source code, unlike say Haskell or most curl-brace languages. While this removes a lot of visual clutter, and the language is designed in such a way that most functions can operate on most types for maximum flexibility, this also means that sometimes things break at run time due to type errors. To make dealing with types easier, spec allows you to place type definitions in strategic places, say at entry- and exit points of an app or a module to ensure that your idea of structure and type of your data still lines up with reality.</p>
<p>The benefit of this approach over static typing is that you can encapsulate parts of your software with type safety without having to deal with the encumbrance in the internals. You define a contract to the outside, but stay flexible in your implementation.</p>
<p>In practice it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> spec-demo
  (<span class="at">:require</span> [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.gen.alpha <span class="at">:as</span> gen]))
            
(s/def <span class="at">::name</span> <span class="kw">string?</span>)
(s/def <span class="at">::age</span> pos-int?)

(s/def <span class="at">::person</span>
  (s/keys <span class="at">:req-un</span> [<span class="at">::name</span>
                   <span class="at">::age</span>]))
                
(s/valid? <span class="at">::person</span>
          {<span class="at">:name</span> <span class="st">&quot;John&quot;</span>
           <span class="at">:age</span> <span class="dv">35</span>})
<span class="co">;; =&gt; true</span>

(s/explain <span class="at">::person</span>
           {<span class="at">:name</span> <span class="dv">35</span>})
<span class="co">;; =&gt; 35 - failed: string? in: [name] at: [:name] spec: :spec-demo/name</span>
<span class="co">;;    {:name 35} - failed: (contains? % :age) spec: :spec-demo/person</span>

(gen/generate
  (s/gen <span class="at">::person</span>))
<span class="co">;; =&gt; {:name &quot;3o311eSXA4Dm9cLkENIt3J5Gb&quot;, :age 3318}</span></code></pre></div>
<p>This snippet demonstrates creating a spec <code>person</code> which has sub-specs <code>name</code> and <code>age</code>, validates some data against the spec, explains why some data does not validate, and also generates some random data compliant with the spec. The last bit is incredibly useful for testing, as you can imagine. There are some more advanced features than what I have shown here, like specs for in- and output types of functions, but this is the gist of it.</p>
<h2 id="so-what-is-wrong-with-spec">So What Is Wrong with spec?</h2>
<h3 id="specs-as-macros">specs as Macros</h3>
<p>spec is implemented using macros, which are compile-time expansions, think template meta-programming in C++. This brings some limitations, which are especially noticeable in Clojure where, like in most other Lisps, code is treated as data and many parts of your software are introspectable at run time. specs are, once defined, not easy to extract data from.</p>
<p>Contrast this with <a href="https://github.com/plumatic/schema">schema</a>, a Clojure library which does essentially the same thing, and got started before spec. schema “schemas” are just hash maps, which are easily constructed and introspected at run time. schema has other problems, but the community seems to generally flock to spec as the officially blessed version.</p>
<p>The situation I have now repeatedly seen is one where I have a spec defining a specific representation of an entity, where for example one spec extends another one. A practical example here is when augmenting an entity with additional data, so that the output representation is a modified version of the input type.</p>
<p>You can define a spec as a superset of another spec, and only in that direction, using <code>s/or</code>, but at that point you are already stuck in the spec an cannot get the list of fields easily out of your specs. It would be nice to be able to define one spec in terms of flat data, which would also be available at run time. This would be incredibly helpful for use with something like <code>select-keys</code>.</p>
<p>There are ways of working around this, for example by using <code>eval</code>, or wrapping your spec macros in another layer of macros, but both of these are more hacks than solutions. <a href="https://github.com/clojure/spec-alpha2/wiki/Differences-from-spec.alpha">spec alpha 2</a> promises to solve this particular problem by separating symbolic specs from spec objects, the former being just flat data which can also be generated programmatically.</p>
<p>If spec alpha 2 works out the way I hope, this will be solved soon, and the documentation looks promising so far.</p>
<h3 id="namespacing">Namespacing</h3>
<p>spec is very intent on you using namespaces for your keywords, which in general is a good idea. Many developers, including myself, have been using the namespace of a key to give context about its use, for example <code>:person/name</code> is a different spec from <code>:company/name</code>. The problem with this is the overloading of namespaced keywords, which are an existing Clojure feature. These namespaces <code>person</code> and <code>company</code> do not actually exist, and I do not want to clutter all my keys with a long prefix like <code>:myapp.entities.person/name</code> to make it match a real namespace.</p>
<p>Now namespaced keywords can have any namespace, and the namespace does not actually have to exist for everything related to keywords to work well, except when it does. If you want to use a spec from another namespace, but <code>alias</code> that namespace to shorten it, you need to <code>require</code> that namespace, for which it needs to exist. As a workaround to this I have created “fake” namespaces in the past using a helper.</p>
<p>This actually leads me to another problem, which is the question of where to place specs in the first place. spec comes with a global, centralised registry for specs, which in alpha 1 you cannot opt out of. In theory this allows you to define/register your spec once in any place you like, and then access it from anywhere without having to know where it comes from or requiring it. This, while having the potential for being too opaque and magical, is actually a very good feature in my opinion. It is trivial to override specs when reloading them, and I have not experienced any issues with evaluation order yet. Due to specs referring to other specs by their name, you can define dependencies of a spec after the fact, and the system will pick them up accordingly.</p>
<p>My current solution for this is having a file &amp; namespace for every entity which can be required and aliased normally, the only problem with this being relationships between specs. As soon as one spec needs to include another spec, dependencies get muddled, so I have experimented with having a special namespace for specs which are shared across many other specs, but this is far from ideal. I wish there was a cleaner way to do this, especially leveraging the global registry.</p>
<h3 id="function-spec-definitions">Function spec Definitions</h3>
<p>I mentioned above that spec also allows instrumenting functions, but the semantics for this are a bit wonky in my opinion. See for yourself:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> double </span>[x]
  (<span class="kw">*</span> <span class="dv">2</span> x))
  
(s/fdef <span class="kw">double</span>
  <span class="at">:args</span> (s/cat <span class="at">:x</span> int?)
  <span class="at">:ret</span> int?
  <span class="at">:fn</span> #(<span class="kw">=</span> (<span class="at">:ret</span> %)
          (<span class="kw">-&gt;</span> % <span class="at">:args</span> <span class="at">:x</span> (<span class="kw">*</span> <span class="dv">2</span>))))</code></pre></div>
<p>This naive spec restricts in- and output types to integers, which is okay in this case. The <code>:fn</code> key describes the relationship between in- and output, and is in this case actually absurdly strict, but this is just an example. There are two issues I have with this:</p>
<p>First the <code>:fn</code> definition tends to be very elaborate and hard to understand at a glance. Even in this simple case, there is a lot going on in there, and the use of anonymous functions does not help it. In practice, this key is optional and I omit it almost always, because I cannot think of any formal assertions I want to make about the output which are also reasonably simple to encode. And if you want to make several separate assertions about the output, you almost cannot avoid breaking up the spec into pieces, at which point you have predicates which exist purely for spec.</p>
<p>The other issue I have is that this is decoupled from the actual function definition. In theory you can place the spec in a different namespace and refer to the function using its fully qualified name, and this is tempting, especially when looking at my previous point about these specs having the potential to be far more longer than the actual function definitions. But then your function exists conceptually in two places, and these two places have to be kept in sync. If you move, rename, or modify the function in almost any way, you have to modify the spec, too, but first you have to find the spec.</p>
<p>The problem I can see with this is that <code>:fn</code> can be used to make assertions about the functions, which can in almost all cases be made in unit tests as well. In fact, unit tests are meant for exactly this, asserting single assumptions about units at a time. The condition above could just as well be a test called <code>the result equals twice the input value</code>. Functions are usually only instrumented locally and/or during testing, as they incur non-negligible overhead, and I would argue that they do not provide significant assurances over unit tests.</p>
<p>I would much rather drop the <code>:fn</code> key, and include type declarations in the actual function definition, which is incidentally how schema works:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(s/defn <span class="kw">double</span> <span class="at">:-</span> s/Int
  [x <span class="at">:-</span> s/Int]
  (<span class="kw">*</span> <span class="dv">2</span> x))</code></pre></div>
<p>In the end, I am looking forward to the next iteration of spec, and hope it addresses as many issues as possible, and I am already blown away by how much better it is than alternatives available in other languages.</p>]]></summary>
</entry>
<entry>
    <title>Building a Literal Library of Building Blocks</title>
    <link href="https://sulami.github.io/posts/building-a-literal-library-of-building-blocks/index.html" />
    <id>https://sulami.github.io/posts/building-a-literal-library-of-building-blocks/index.html</id>
    <published>2019-02-02T00:00:00Z</published>
    <updated>2019-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I know, insert the obligatory “I haven’t posted in a while” bit here.<br />
<br />
</span></span> is heavily inspired by <a href="https://soundcloud.com/defn-771544745/30-zach-tellman-aka-ztellman">a remark Zach Tellman made on the defn podcast</a>, where he says:</p>
<blockquote>
<p>Having been a professional programmer for a decade, I have a decade’s worth of experience at writing stuff from scratch, not a decade’s worth of tools in my toolbox. And that seems like a not optimal set of circumstances. <em>[Quote at 57:45]</em></p>
</blockquote>
<p>I have listened to this some time around Christmas, and this quote has kept me thinking over the past couple of months. What Zach is talking about is a project he is working on which would allow you to capture explorative programming in the branching fashion in which it happens. His example revolves around using a shell to perform some work, like extracting some specific values from a file.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">You should really go and listen to the episode, he has a lot of very great insights.<br />
<br />
</span></span> He explains how we work out these sequences of commands that to accomplish our goal, but never generalise them, but instead throw them away, just to write them from scratch the next time we encounter a similar problem. This rings true for all kinds of programming, not just shell scripting, though shell scripts are especially susceptible to this.</p>
<p>Like Zach, I believe this to be a suboptimal situation. Especially being a functional programmer, I believe in small, abstract building blocks, composition, and code reuse, rather than overly specific, bespoke solutions that have to be written from scratch every time. I am someone who tinkers a lot, and there is a lot of code I never commit anywhere. As a matter of fact, I have a habit of creating throw-away files or whole projects in <code>/tmp</code> just to play with something for anywhere between five minutes and a weekend. At the same time I also have a repository on my Github literally called playground, which contains all kinds of small things that I did not want to go through the hassle of creating a Github repository for.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Interesting aside: while creating a local repository has so little friction that I do it all the time, only a fraction of them ever touch Github’s servers, as creating a repository through the web interface incurs so much friction.<br />
<br />
</span></span></p>
<p>This repository has allowed me to cannibalise some snippets of codes I used in the past, but it is not what I would call a comprehensive library of generalised solutions to problems I repeatedly face. And that has been hugely helpful already, for example I have written about path-finding using the A* algorithm before, so I had a working implementation ready when I needed it for another project.</p>
<p>Having a library, in the worldly sense of the word, of useful, generalised snippets of code would institutionalise the knowledge of them. You would not have to remember how to invert a binary tree, because if you have ever played with binary trees you would already have an implementation handy, and it would be tried and tested, and performance-optimised.</p>
<h2 id="practical-implementations">Practical Implementations</h2>
<p>Having arrived at the decision of generalising and collecting useful snippets of code somewhere, we are now facing the question of where somewhere actually is, and how we distribute the snippets in a way that allows us to easily use them.</p>
<p>The simplest solution would be to maintain one or several collections of useful snippets, and just copy-pasting them into the code you are writing. While this is fast and simple, it does not facilitate innovation flowing in either direction. Updates to the generalised versions are not included in downstream products using them, and vice versa. The result would likely be a duplication of similar, but subtly different solutions to all kinds of problems, scattered over various projects. Bugs that have long been fixed in one of them might still be present in others.</p>
<p>The alternative solution is packaging your snippets, and using them as a library. Most of the practical implementation will depend on the programming language you are using, and what kind of projects you are usually working on. Zach Tellman himself has a Clojure library called <a href="https://github.com/ztellman/potemkin">Potemkin</a>, which is a collection of “some ideas which are almost good”, and which he uses as a dependency for most of his other libraries.</p>
<p>While this incurs some overhead, namely the packaging of the library, it does come with a lot of advantages. Other people can benefit from your library. Depending on the scale of the overhead involved with building a library, splitting snippets by topic into “actual” libraries might make sense. It does require more abstraction, and more documentation, but that is not a bad thing. For a simple library with a handful of data structures or functions, writing a quick readme and some docstrings takes less than an hour.</p>
<p>There is still room for a default, catch-all library that is just for personal use and contains miscellaneous snippets without any particular topic, and it can be where new snippets end up first. If a section of it grows large enough, it can be extracted into its own library. The bottom line here is, if you write something that solves a problem, keep it somewhere, ideally where you can find it again. Even if it is not generalised or documented, it might come in handy in the future.</p>]]></summary>
</entry>
<entry>
    <title>Genetic Programming in Clojure</title>
    <link href="https://sulami.github.io/posts/genetic-programming-in-clojure/index.html" />
    <id>https://sulami.github.io/posts/genetic-programming-in-clojure/index.html</id>
    <published>2018-11-17T00:00:00Z</published>
    <updated>2018-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="the-theory">The Theory</h2>
<p>Like most programmers I have always had a vague interest in AI, and one of its branches that requires less complicated maths than recurrent neural networks which are the most well known one, is genetic programming. The idea of genetic programming is quite simple<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">If you are into more visual examples, this I believe is a very good practical example: <a href="http://rednuht.org/genetic_cars_2/" class="uri">http://rednuht.org/genetic_cars_2/</a><br />
<br />
</span></span>:</p>
<ol style="list-style-type: decimal">
<li>You build something that is parameterised in key places</li>
<li>You build a scoring function to assess the performance of your something with a set of parameters</li>
<li>You randomly adjust (mutate) your parameters in some way a couple of times and compare the score of each set</li>
<li>You take the best one or ones as a base to start a new round of mutations and scoring</li>
<li>Basically just repeat steps 3 &amp; 4 for a while and your parameters will tend towards a maximum score</li>
</ol>
<p>Depending on a variety of meta-parameters that control for example the size of each generation or the nature of the mutations you might just find a local maximum, but often times this can yield pretty good results for a variety of problems.</p>
<h2 id="the-practice">The Practice</h2>
<p>I have toyed around with this over the last couple of days and built an very simple abstract implementation in Clojure, which I am going to share here (and eventually will be somewhere on Github as well). Let us explore it from the inside out.</p>
<p>First of all we need to be able to generate some mutations of our specimen. Because we do not assume anything about the specimen, this ends up being quite simple because a lot of the heavy lifting is done outside of this implementation as it is specific to the problem in question.</p>
<p>This returns a potentially infinite list containing first the specimen passed in, and then as many mutations of it as we want.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> mutate</span>
  <span class="st">&quot;Generator that mutates a base, the first element being the base.&quot;</span>
  [base mutator]
  (<span class="kw">concat</span> [base]
          (<span class="kw">repeatedly</span> #(mutator base))))</code></pre></div>
<p>Next we also need to be able to score it. In this case we would like to attach the scores to the specimens so that we can use them to sort and select specimens without losing the specimens themselves.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> attach-score</span>
  <span class="st">&quot;Attaches the score to a specimen.&quot;</span>
  [score-fn specimen]
  [specimen (score-fn specimen)])</code></pre></div>
<p>Now let us begin to tie these together. A single generation should take a base specimen, mutate it a couple of times, score each of them, and then select the “fittest” based on the scores<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">This also only keeps the best specimen in every generation, which makes the code much simpler. For actual real world usage it might be beneficial to keep the best <code>n</code> specimens in every generation to avoid running into local maxima. This would make the mutation slightly more complex though because there would be several base specimens which need to be mutated, so I decided to leave out this feature for the purposes of explanation.<br />
<br />
</span></span>. Note that in this implementation a lower score is better. To change this just reverse the sorting.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> generation</span>
  <span class="st">&quot;Picks out the best one from a generation.&quot;</span>
  [base mutator score-fn gen-size]
  (<span class="kw">-&gt;&gt;</span> (mutate base mutator)
       (<span class="kw">take</span> gen-size)
       (<span class="kw">map</span> (<span class="kw">partial</span> attach-score score-fn))
       (<span class="kw">sort-by</span> <span class="kw">second</span>)
       <span class="kw">first</span>
       <span class="kw">first</span>))</code></pre></div>
<p>And to finish off, we just need to run a number of generations, each based on the previous one’s winner.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> evolution</span>
  <span class="st">&quot;Generator for generations.&quot;</span>
  [base mutator score-fn gen-size]
  (<span class="kw">iterate</span> #(generation % mutator score-fn gen-size) base))</code></pre></div>
<p>The lazy nature of this implementation is allows us to inspect intermediate results easily, as we can see the path evolution has taken in the form of each generation’s winner.</p>
<h2 id="the-actual-practice">The Actual Practice</h2>
<p>Now this above is actually not that much code, and it is very abstract in its nature, so let us have a look at what it looks like when we actually use it. A simple example would be approximating a single number that is hard to approximate, like √2.</p>
<p>Our specimen is just a float, and any will do as the initial seed. It is itself the only parameter.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> base </span><span class="fl">0.0</span>)</code></pre></div>
<p>To mutate it, we just adjust it by a random amount within <code>0.5</code> in either direction.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> mutator </span>[base]
  (<span class="kw">-&gt;</span> (<span class="kw">rand</span>)
      (<span class="kw">-</span> <span class="fl">0.5</span>)
      (<span class="kw">+</span> base)))</code></pre></div>
<p>Our scoring function is cheating a little, because we already know the target, we can just compare against it and use the distance as the score.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> score-fn </span>[x]
  (<span class="kw">-&gt;</span> x
      (<span class="kw">-</span> (Math/sqrt <span class="dv">2</span>))
      Math/abs))</code></pre></div>
<p>Now when we run this, we can see how it approximates the target value over time (<code>√2 ≈ 1.4142</code>).</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">take</span> <span class="dv">6</span> (evolution base mutator score-fn <span class="dv">25</span>))
<span class="co">;; =&gt; (0.0</span>
<span class="co">;;     0.33079046010191426</span>
<span class="co">;;     0.7509224756253191</span>
<span class="co">;;     1.2164225056336746</span>
<span class="co">;;     1.3768753691848903</span>
<span class="co">;;     1.4125030676422798)</span></code></pre></div>
<p>Because <code>evolution</code> returns an infinite sequence, we can just use <code>nth</code> on it to get the winner after a certain number of generations.</p>
<p>While this is a very simple example, I am currently working on a way of using this to build and mutate a Clojure <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> and score it by running a series of unit tests against the generated code. If this works out I might write about it here soon.</p>]]></summary>
</entry>
<entry>
    <title>Working remotely (Part 2)</title>
    <link href="https://sulami.github.io/posts/working-remotely-part-two/index.html" />
    <id>https://sulami.github.io/posts/working-remotely-part-two/index.html</id>
    <published>2018-11-05T00:00:00Z</published>
    <updated>2018-11-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It has now been 48 days since the first part of this post, and 42 days since I moved into my current flat in Amsterdam. Time for me to write the promised follow-up and explain what has happened so far and how things have been going.</p>
<h2 id="the-good">The Good</h2>
<p>First of all, I am a lot happier in my personal life, moving was definitely the right decision for me in general, all work things aside. Having made the step into a remote agreement frees me up to move when- and wherever I want, as my employer does not care about from where I actually work at this point, apart from timezone-related concerns.</p>
<p>I also think that full control over my workspace can drastically improve my productivity, the main benefit being the lack of distractions.</p>
<p>Last time I mentioned that I would go back to London once a month. So far I am keeping to this schedule, and my first visit has been quite pleasant, even if a little stressful. But being able see my team members in person, catching up and meeting new hires allows us to stay more in touch. My only minor complaint is that travel is quite a hassle, especially at this rate, so I might try to turn down the frequency a bit.</p>
<h2 id="the-bad">The Bad</h2>
<p>After the moving process, which included being legally homeless for a weekend in France, I was quite happy to be able to stay home for a bit, so I ended up working from my living room for a couple of weeks. In addition to that, coworking spaces are (to me) surprisingly expensive for what they are.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">200€/mo. for something they call “a desk” but in reality is just a slot at a table, electricity, wifi and access to a kitchen with free coffee is quite a lot in my opinion. If I wanted an actual desk and office chair, ideally with a set of walls around it, I can expect to pay at least twice that.<br />
<br />
</span></span> But after a while I started suffering from both cabin fever and loneliness, so I bit the bullet and subscribed to one. This also ended up being the right decision, because just the way I wrote the last time, I have a physical location I can go to to work, but it is purely optional.</p>
<p>In addition to potential extra costs and stress due to more traveling, some employers also seem to think that remote workers should by default earn less than the ones coming into the office. It is true that remote work in and of itself can be seen as a perk, but I also believe that correctly executed remote work is beneficial to everyone involved.</p>
<h2 id="closing-notes">Closing Notes</h2>
<p>If you want to go remote I recommend you do what I (we) did and get a remote working agreement that is signed by you and your employer. It should capture the terms of the remote work, such as work hours, visits, who pays for transport and how long much in advance a warning needs to be given for you to be called into the office.</p>
<p>The last point is quite important especially if you are expected to pay for transport (and possibly lodging) which can be much more expensive if booked spontaneously.</p>]]></summary>
</entry>
<entry>
    <title>Running Clojurescript Tests on the JVM</title>
    <link href="https://sulami.github.io/posts/running-clojurescript-tests-on-the-jvm/index.html" />
    <id>https://sulami.github.io/posts/running-clojurescript-tests-on-the-jvm/index.html</id>
    <published>2018-10-01T00:00:00Z</published>
    <updated>2018-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I have been writing a lot of Clojure and Clojurescript for my side projects. This is my first post on the language &amp; ecosystem, so I what follows below might be very wrong in places. Nontheless I want to share something I worked out myself and might be useful to someone else. The topic we’re going to be looking at is running (unit) tests for a <a href="https://github.com/Day8/re-frame">re-frame</a>-based Clojurescript application, though it actually applies to almost any CLJS application.</p>
<p>Last week I was finally adding tests to one of my side projects<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Way too late as well, I should have <a href="https://www.obeythetestinggoat.com">obeyed the testing goat</a>. I had quite some trouble untangling my wild-west design to be able to even write proper unit tests.<br />
<br />
</span></span> and I was wondering how to run them easily. Clojure comes with a great bulid tool, <a href="https://leiningen.org">leiningen</a>, which allows you to run tests quite easily, at least for Clojure code.</p>
<h2 id="ways-to-run-tests">Ways to Run Tests</h2>
<p>Now the way I run my code is by compiling my code to Javascript, launching a browser session through Leiningen, and running my code in the browser’s runtime. This works very well for actually running the code using <a href="https://github.com/bhauman/lein-figwheel">figwheel</a>, but less well for running tests.</p>
<p>The first reason this is a bit impractical is because it requires a lot of setup to actually make it work, you need to update your <code>project.clj</code> to have a testing build, which needs proper cleaning up as well, and then somehow manage the browser runtime as well. Depending on how you do this, this also incurs heavy startup time penalties.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Full test compiles from CLJS to JS for a small test suite (~20 test cases) already takes about 5-10 seconds.<br />
<br />
</span></span></p>
<p>To avoid the browser, which is just unnecessarily heavyweight if all you need is just a JS runtime, the go-to solution used to be <a href="http://phantomjs.org">PhantomJS</a>, a headless browser that can be used for various tasks that do not require an actual human seeing rendered output. Sadly, PhantomJS suspended development earlier this year due to lack of active contributors, so I am not very confident in building on top of it, especially considering the speed at which the web and standards are currently changing.</p>
<p>While PhantomJS comes with a whole DOM emulation, what we are actually looking for is only a JS runtime, for reasons that will become apparent later. This leads us to <a href="https://nodejs.org/en/">Node.js</a>, which is exactly that, a stand-alone JS runtime. Running tests inside Node is quite a viable option, as it does not impose any meaningful startup time penalty by itself, meaning we can just start it up fresh for every test run and not <a href="https://twitter.com/garybernhardt/status/1007699556832817152">have to deal with persistence and state</a>.</p>
<p>We could stop there, write a custom test build target and a custom test command that just runs that file for Leiningen and be done with it. But we still have the compilation time to JS which is just too long if you want to have a very tight TDD loop. Then I realised that we do not actually need to compile to JS at all, in the end we just want to test Clojure code, which can run on a variety of different platforms.</p>
<p>One of the fastest platforms available to us is the original platform Clojure targeted, the JVM. Because I am using Emacs with <a href="https://github.com/clojure-emacs/cider">CIDER</a>, I already have a long-running JVM<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">I know we are back to long-running processes, which is a bit unfair, but CIDER allows me to basically instantaneously reload the whole project, which so far worked without any hiccups.<br />
<br />
</span></span>, I do not even have to consider the ~1s startup time the JVM incurs. This setup allows us to run tests in well under one second, but leads me to the next section.</p>
<h2 id="the-theory-decoupling-logic-from-presentation">The Theory: Decoupling Logic from Presentation</h2>
<p>If we want to run our Clojure code, which does not specify a target platform, on the JVM, we cannot depend on any platform-specific features. This means, our Clojurescript application needs to be split into platform-independent Clojure code and Clojurescript glue code. Incidentally, this is also the structure TDD favours and I think that leads to the code easiest to reason about.</p>
<p>re-frame does come with an <a href="https://github.com/Day8/re-frame/blob/master/docs/Testing.md#exposing-event-handlers-for-test">example of how to expose event handlers for tests</a>, which are the part of our application that should contain the bulk of the application logic. The basic gist is this: any kind of state should be mutated by passing it into a pure function, which just returns the new, modified state. Every variable is state.<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Ideally abandon the idea of a variable as well, default to immutable values everywhere.<br />
<br />
</span></span> Then use the most basic glue code you can come up with to glue this together.<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">This is really just functional programming, which has been around for over half a century.<br />
<br />
</span></span></p>
<p>This allows us to then test the application logic in isolation, by just passing a piece of state into a function and checking properties on the returned value. If it makes sense, we can also use properties to randomly generate a huge amount inputs according to some rules and make sure that we do not forget any edge cases we did not think of writing tests for. Because none of this code actually depends on anything related to the presentation, it does not matter whether it runs in a browser or on the JVM.</p>
<h2 id="the-practice-the-implementation-of-re-frame-tests">The Practice: The Implementation of re-frame Tests</h2>
<p>In order to be able to run Clojure code on the JVM, it cannot be Clojurescript code, meaning it cannot reside in <code>.cljs</code> files and cannot use CLJS-specific libraries, but some of your code will invariably be specific to Clojurescript, like for example</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> foo.bar
  (<span class="at">:require</span> [cljs.spec.alpha <span class="at">:as</span> s]))</code></pre></div>
<p>needs to be</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> foo.bar
  (<span class="at">:require</span> [clojure.spec.alpha <span class="at">:as</span> s]))</code></pre></div>
<p>to work on the JVM. This can be solved quite easily by using <a href="https://clojure.org/guides/reader_conditionals">reader conditionals</a>. The basic idea is to save your application logic in Common Clojure (<code>.cljc</code>) files, write the wrapper around your application in Clojurescript (<code>.cljs</code>) and your test suite in Clojure (<code>.clj</code>). Within Common Clojure you have access to reader conditionals which are a feature in Clojure &gt;= 1.7 which allow modifying code at “compile-time”<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">I do not actually know in depth how this works behind the scenes yet, but I believe this is a fair approximation even if potentially inaccurate.<br />
<br />
</span></span> depending on the compilation target. This is what it looks like in action:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> foo.bar
  (<span class="at">:require</span> #?(<span class="at">:clj</span>  [clojure.spec.alpha <span class="at">:as</span> s]
               <span class="at">:cljs</span> [cljs.spec.alpha <span class="at">:as</span> s])))</code></pre></div>
<p>Once we are at this point, writing the actual tests is quite easy. I am going to borrow an example from the <a href="https://github.com/Day8/re-frame/blob/master/docs/Testing.md">re-frame docs</a> here:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [
      <span class="co">;; setup - cummulatively build up db</span>
      db (<span class="kw">-&gt;</span> {}    <span class="co">;; empty db</span>
             (initialise-db [<span class="at">:initialise-db</span>])   <span class="co">;; each event handler expects db and event</span>
             (clear-panel   [<span class="at">:clear-panel</span>])
             (draw-triangle [<span class="at">:draw-triangle</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))

      event  [<span class="at">:select-triange</span> <span class="at">:other</span> <span class="at">:stuff</span>]

      <span class="co">;; now execute the event handler under test</span>
      db&#39;    (select-triange db event)]

      <span class="co">;; validate that db&#39; is correct</span>
      (<span class="kw">is</span> ...)</code></pre></div>
<p>In this example, <code>db</code> is the global state map, which gets passed into a chain of pure event handler functions, after which the returned new state can be validated. All we need to do to run these is set a <code>:test-paths</code> setting in <code>project.clj</code> and <code>lein test</code> will pick up the tests.</p>]]></summary>
</entry>
<entry>
    <title>Working Remotely (Part 1)</title>
    <link href="https://sulami.github.io/posts/working-remotely-part-one/index.html" />
    <id>https://sulami.github.io/posts/working-remotely-part-one/index.html</id>
    <published>2018-09-18T00:00:00Z</published>
    <updated>2018-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>As of next week I will be full-time working remotely again, after having worked on-site for almost two years now. This weekend I will be moving from London back to what they call Europe or the continent here in London, specifically Amsterdam.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Even though it does play a minor role, this is not directly due to Brexit and more a personal lifestyle choice.<br />
<br />
</span></span> As I worked full-time remotely before, two years ago, I have some experience and I want to lay out my ideas and plans to make this a successful endeavour. Part two will be published in a few weeks and give an update on how things are going once I settled in.</p>
<h2 id="how-this-came-to-happen">How This Came to Happen</h2>
<p>As I mentioned above, I am moving for non-work related reasons, but part of me is also looking forward to not having to commute or spending days inside an open-plan office. Over the last couple of months I have transitioned to work usually one day per week from home, so this is definitely a benefit in my book. I also have to thank my current employer, <a href="https://ostmodern.co.uk">Ostmodern</a>, for being really accommodating in this regard. When I approached them about moving countries, but still wanting to stay with them, they were directly on board. We wrote up a special agreement that states modifies my normal contract and defines the parameters of our new employment relationship.</p>
<h2 id="difficulties-i-expect-and-prevention-strategies">Difficulties I Expect and Prevention Strategies</h2>
<p>When I moved to London to work on-site, I did so not only because it was significantly easier, at least at the time, to find a job on-site rather then remotely, but also because I felt quite disconnected from my colleagues who I only got to meet in person every couple of months. From time to time I would also feel a bit lonely, working all by myself.</p>
<p>To circumvent these issues, we have agreed upon not only daily video conferences, but also for me to come in once a month for two days to spend some time with the rest of the team, have face-to-face meetings and catch ups and just feel more involved. This should also help the rest of the team to not just see me as an entity reachable via Slack or email.</p>
<p>In addition to that, I am actually not moving by myself, but I am taking a good friend and my closest team member with me, so I will have someone physically present most of the time to bounce ideas off.</p>
<p>Another problem I experienced before was having a hard time separating work and private life, which can have negative impacts on both. The solution for these I think is quite simple and obvious, I will rent a coworking space and artificially commute there at least most of the time. This way I can focus on getting work done while there and also leave work behind once I get home. Because I get total freedom in this, I can still work from home if the weather is terrible or I do not feel like going outside, and I get to pick the exact length of commute I want.</p>
<p>Lastly I am foreseeing a new problem I have not faced in this way before, and this is related to the fact that I now lead a small team and own several products, one of them being our core backend platform. This makes me the central entry point for a lot of people from other teams, and I am usually the person invited to meetings where some platform knowledge is required. We decided that I am going to keep both of these responsibilities, but we are going to install an ambassador who is going to be working on-site and will be easier to talk to. This ambassador is a fellow senior backend engineer who I will catch up with regularly to make sure we are both on top of things.</p>
<h2 id="where-to-go-from-here">Where to Go from Here</h2>
<p>I will be moving this upcoming weekend, as of time of posting, and resume working as soon as possible next week. As mentioned in the beginning, there will be a follow-up post in a couple of weeks, once the dust (and I) has settled, where I will draw some conclusions on the predictions I made above and write about what works and what does not.</p>]]></summary>
</entry>
<entry>
    <title>Pipes in Python</title>
    <link href="https://sulami.github.io/posts/pipes-in-python/index.html" />
    <id>https://sulami.github.io/posts/pipes-in-python/index.html</id>
    <published>2018-08-21T00:00:00Z</published>
    <updated>2018-08-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just found <a href="https://hackernoon.com/adding-a-pipe-operator-to-python-19a3aa295642">an article about pipes in Python</a> on lobste.rs and was reminded that I was toying with the exact same thing recently. Using a lot of functional languages (mainly Haskell, Clojure, Elixir)<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">… but being paid to write (mostly highly object-oriented) Python four out of five days a week. We do use some Elixir at my place, but we are still a Python shop first.<br />
<br />
</span></span> and also a fair bit of bash, I am very used to streaming data through chains of functions using pipe-like constructs. Python does make this quite difficult and encourages a more imperative approach with intermediate variables.</p>
<p>The author of the article above uses AST rewriting, which I have to admit is very clever, though hard to introspect and extend unless you are already familiar with AST manipulation in Python.</p>
<p>My approach is slightly different, and yields a less pretty syntax, but is arguably more flexible and extensible, by using a plain function. The definition currently looks like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> pype(x, <span class="op">*</span>fs):
    <span class="co">&quot;&quot;&quot;</span>
<span class="co">    Pipe function. Takes an initial value and any number of functions/methods.</span>
<span class="co">    Methods as strings. Additional args are supported for functions &amp; methods</span>
<span class="co">    by suppling a step as a tuple/list with function/method as the first</span>
<span class="co">    element and the args as the rest. The pipe input is used as the last</span>
<span class="co">    argument in this case. Currently no kwargs.</span>
<span class="co">    &quot;&quot;&quot;</span>
    <span class="cf">while</span> fs:
        f <span class="op">=</span> fs[<span class="dv">0</span>]
        args <span class="op">=</span> []
        <span class="cf">if</span> <span class="bu">isinstance</span>(f, (<span class="bu">list</span>, <span class="bu">tuple</span>)):
            args <span class="op">=</span> <span class="bu">list</span>(f[<span class="dv">1</span>:])
            f <span class="op">=</span> f[<span class="dv">0</span>]
        <span class="cf">if</span> <span class="bu">isinstance</span>(f, <span class="bu">str</span>):
            <span class="cf">if</span> f.startswith(<span class="st">&#39;.&#39;</span>):
                x <span class="op">=</span> <span class="bu">getattr</span>(x, f[<span class="dv">1</span>:])(<span class="op">*</span>args)
            <span class="cf">else</span>:
                x <span class="op">=</span> x[f]
        <span class="cf">elif</span> <span class="bu">isinstance</span>(f, <span class="bu">int</span>):
            x <span class="op">=</span> x[f]
        <span class="cf">else</span>:
            x <span class="op">=</span> f(<span class="op">*</span>args <span class="op">+</span> [x])
        fs <span class="op">=</span> fs[<span class="dv">1</span>:]
    <span class="cf">return</span> x</code></pre></div>
<p>The docstring is a bit abstract, so I think an example is much more explanatory:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> pype <span class="im">import</span> pype

<span class="kw">def</span> add_suffix(number, s):
    <span class="cf">return</span> <span class="st">&#39;</span><span class="sc">{}</span><span class="st"> is </span><span class="sc">{}</span><span class="st"> cool!&#39;</span>.<span class="bu">format</span>(
        s,
        <span class="st">&#39; &#39;</span>.join(<span class="st">&#39;very&#39;</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(number))
    )

pype(
    <span class="st">&#39;   abc: </span><span class="sc">{}</span><span class="st">   &#39;</span>,
    <span class="st">&#39;.strip&#39;</span>,
    (<span class="st">&#39;.format&#39;</span>, <span class="dv">3</span>),
    (add_suffix, <span class="dv">2</span>),
    <span class="st">&#39;.upper&#39;</span>,
)

<span class="co"># &#39;ABC: 3 IS VERY VERY COOL!&#39;</span></code></pre></div>
<p>I am aware this is a very constructed example, but you get the idea. It currently does not handle keyword arguments, and you cannot specify in which place you would like the input argument to go, it always takes the last slot, which isn’t always convenient, but this way you can avoid using <code>lambda</code>s everywhere, which are quite long in Python<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">I quite enjoy Elixir’s solution: <code>&amp;func(1, &amp;1, 3)</code>, <code>&amp;1</code> being the placeholder.<br />
<br />
</span></span>.</p>
<p>I might extend this further in the future and maybe introduce it into some code bases of mine, if it turns out to be useful.</p>]]></summary>
</entry>
<entry>
    <title>How this blog is made</title>
    <link href="https://sulami.github.io/posts/how-this-blog-is-made/index.html" />
    <id>https://sulami.github.io/posts/how-this-blog-is-made/index.html</id>
    <published>2018-07-26T00:00:00Z</published>
    <updated>2018-07-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While this blog has always been powered by a static-page generator, a while ago I switched from using <a href="https://blog.getpelican.com/">Pelican</a>, a Python-based generator, to <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, a Haskell-based one. There was no real practical reason for this, and objectively the switch has been a huge waste of time, though I have learned a lot about Haskell and am very happy with how this blog currently works.</p>
<p>The basic setup is quite simple, I am using <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> to manage build dependencies and sandboxing for Haskell<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">This is actually one of my basic requirements for new languages that I pick up. It is 2018, you can ship your language with a package manager that sandboxes by default. One of my biggest problems with Python is virtualenv.<br />
<br />
</span></span>. For reasons that become clear later in this post, I also need a LaTeX installation, which currently is not managed in any way, but I do not require anything out of the ordinary, so usually it is just a matter of install ing the distribution for my operating system.</p>
<h2 id="hakyll-hacks">Hakyll Hacks</h2>
<p>To achieve a nice, human-readable URL scheme I am not only generating a slug from the original file name, which usually matches the title, but to get rid of the ugly <code>.html</code> postfix I actually render all pages and posts to <code>index.html</code> files in directories with the corresponding name, resulting in URLs with trailing slashes. Credit for this goes to <a href="https://www.rohanjain.in/hakyll-clean-urls/">Rohan Jain</a>.</p>
<p>Of course this blog also has an Atom feed<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Atom vs. RSS has been <a href="https://nullprogram.com/blog/2013/09/23/">debated for a while</a>, in the end my use case is super simple anyway, so I am just using Atom until I find an actually valid reason to get into comparing the two formats.<br />
<br />
</span></span>, so you can follow my posts in your favourite newsreader, or use Firefox live bookmarks for example. I ran into one particular problem with this though, as one of my recent posts included an ampersand (&amp;) in the title. The rendered feed file (no matter the format) would be invalid due to this. So I had to implement <a href="https://en.wikipedia.org/wiki/Percent-encoding">URL encoding</a> for titles myself (this is already done for the body by Hakyll). Thanks to the way Hakyll embraces the Haskell philosphy, this was just a matter of mapping the encoding function over the post titles for the feed output.</p>
<h2 id="symetric-html-pdf-output">Symetric HTML &amp; PDF output</h2>
<p>A long while ago I had the idea of making my CV available online in the browser, like many front end developers do to showcase their skills. At the same time I still need a PDF version that can be printed neatly. Being a developer, I of course cannot fathom the idea of having two sets of CVs, so I thought why not generate both versions from the same source (of truth), using one single build process. So that is what I am currently finalising.</p>
<p>The HTML version for the website is just a static page in the blog, simple enough. Hakyll gives me very fine-grained control over the actual build process, so I can leverage custom Markdown tags to control layout if I need to. The PDF version of my CV has always been generated using <a href="https://www.latex-project.org/">LaTeX</a>, because it generates beautifully rendered output in a reproducible fashion. Because I am using <a href="http://pandoc.org/">Pandoc</a> to generate HTML from the Markdown source, I am also using it to generate the LaTeX source code from the same source, and then just pass it into a LaTeX template. Then I just run <code>xetex</code> in a subprocess to render the final PDF.</p>
<h2 id="deployment">Deployment</h2>
<p>This blog is currently hosted in two locations, <a href="https://pages.github.com/">Github Pages</a> which I have been using for many years, and <a href="https://docs.gitlab.com/ee/user/project/pages/">GitLab pages</a>, which I only added recently. While the build and deployment process for these two platforms is slightly different, they mostly work off the same codebase, with the only difference being a <a href="https://github.com/sulami/sulami.github.io/blob/develop/Makefile">makefile for Github</a> being replaced by the <a href="https://gitlab.com/sulami/sulami.gitlab.io/blob/develop/.gitlab-ci.yml">GitLab-specific build file</a>. The Github version I generate locally with my locally compiled Hakyll, and then push the the right branch using the makefile. This makefile also allows me to run a local server to preview the rendered output before committing. The GitLab repository is setup to mirror the one on GitHub and rebuild via GitLab CI on every change, so it is compiling the Hakyll application in a Docker container and the generating the output.</p>
<p>These two build processes have different pros and cons. The GitHub version is available slightly faster, as my local render only takes a couple of seconds and after pushing I just have to wait for Github’s cache to refresh, which usually takes only a couple of minutes, while the GitLab version has to run the CI job which takes a couple of minutes. On the upside the GitLab version does not require me to have a locally installed version of Haskell, Stack or anything else, as long as I can push to the repository, allowing me to explore workflows which happen end-to-end on iOS. I have been investigating this exact workflow, using a combination of <a href="https://itunes.apple.com/us/app/ia-writer/id775737172">iA Writer</a>, <a href="https://itunes.apple.com/us/app/workflow/id915249334">Workflow</a> and <a href="https://itunes.apple.com/us/app/working-copy/id896694807">Working Copy</a> to write, transform and push the posts, leaving the build process to GitLab CI.</p>
<p>If you are interested in details, have a look at the source on either <a href="https://github.com/sulami/sulami.github.io">Github</a> or <a href="https://gitlab.com/sulami/sulami.gitlab.io">GitLab</a>.</p>]]></summary>
</entry>
<entry>
    <title>Does popularity matter when choosing a stack?</title>
    <link href="https://sulami.github.io/posts/does-popularity-matter-when-choosing-a-stack/index.html" />
    <id>https://sulami.github.io/posts/does-popularity-matter-when-choosing-a-stack/index.html</id>
    <published>2018-06-29T00:00:00Z</published>
    <updated>2018-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently there has been a lot of turmoil around <a href="https://github.com/vuejs/vue">Vue.js</a> <a href="https://hasvuepassedreactyet.surge.sh">reaching the same number of stars on GitHub</a> as <a href="https://github.com/facebook/react">React</a>. While stars on GitHub are far from a reliable indicator of actual popularity and size of user base, it does raise the question whether these should actually matter when choosing a stack for a new piece of software.</p>
<p>The easy answer is that it should not really matter. Especially if you are working in a somewhat specialised environment or are under a lot of constraints, like low-power hardware or strict performance requirements, you will probably end up using a very domain-specific set of tools. A language like Kotlin is the recommended way forward if you are developing an android application, but looking at the <a href="https://www.tiobe.com/tiobe-index/">TIOBE index</a><span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I have to mention that I believe the TIOBE index to be a bit biased though, not that I was perfectly objective. The overall “winner” of 2013 is Transact-SQL, a language many programmers will not even have heard of.<br />
<br />
</span></span>, and still it only comes in at position 49 at the time of writing, so obviously popularity cannot matter more than platform constraints.</p>
<p>Another quite important factor is the already present repertoire of tools. Many tools, especially languages and large frameworks, like Vue.js and React, require rather large upfront learning efforts before they can be used efficiently. If you already know React inside out, why would you learn Vue, assuming it fundamentally does not enable you to do anything React does not? I am currently paying for my food by writing code in a primarily Python/Django environment, and sometimes I look over at the neat lawn the Ruby on Rails crowd seems to have, but it would not be wise of me to invest a sizeable amount of time to switch ecosystems without actually gaining much.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Apart from that Python is also larger and growing in comparison to Ruby. Ruby is probably not dying anytime soon, but it is definitely declining since the days when everything was Rails, much to my dismay.<br />
<br />
</span></span></p>
<p>I can already hear you type your furious <a href="https://twitter.com/_sulami_">tweets at me</a>, claiming how popularity of course makes a difference. And you are not wrong, there are very valid arguments to be made.</p>
<p>Popularity does indeed matter when you chose a technology to use, for example if you need to add support for a new data format and shop around for libraries. Especially in the open-source world a larger user base means more eyes scanning the code for bugs, more potential contributors keeping the software updated and supplying it with new features, and better chances it will stay maintained overall. If you use a common set of softwares, chances are they can interact easily in some way, saving you time for integrating them. All of these are important factors which should be considered when making a voice of tooling.</p>
<p>In the end there is no single deciding factor to look at, like for example popularity, but instead a lot of different ones. It is crucial to recognise all of them and think about how to weight them in importance. Newer (and shiny) tools might offer significant gains, but come at the price of a smaller community, so less support and a higher risk of abandonment.</p>]]></summary>
</entry>

</feed>
