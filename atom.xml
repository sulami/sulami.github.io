<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>sulami's blog</title>
    <link href="https://sulami.github.io/atom.xml" rel="self" />
    <link href="https://sulami.github.io" />
    <id>https://sulami.github.io/atom.xml</id>
    <author>
        <name>Robin Schroer</name>
        <email>blog@peerwire.org</email>
    </author>
    <updated>2020-06-10T00:00:00Z</updated>
    <entry>
    <title>LISP&lt;sub&gt;1&lt;/sub&gt; Has Won</title>
    <link href="https://sulami.github.io/posts/lisp-1/index.html" />
    <id>https://sulami.github.io/posts/lisp-1/index.html</id>
    <published>2020-06-10T00:00:00Z</published>
    <updated>2020-06-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I am currently working on a compiler for a new programming language which has been in the making for a few months at this point. There is nothing public to show yet, everything is very early stage, and there are plenty of decisions to make and work to be done before I will publish anything.</p>
<p>That being said, I will write about both the progress as well as different topics I come across, so <a href="/atom.xml">stay tuned</a> if you are interested in that.</p>
<p>The language I am writing currently has a Lisp-like syntax, because that is easy to parse an work with,<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I just really don’t want to deal with operator precedence, and honestly I like writing Lisp, so I find it unlikely that I’ll actually change to a non-Lisp-like syntax.<br />
<br />
</span></span> which is why I am sharing some thoughts on one of the big bike sheds in software history.</p>
<h2 id="lispwhat">LISP<sub>what?</sub></h2>
<p>LISP<sub>1</sub> and LISP<sub>2</sub> are terms to describe the way symbol namespaces work in different LISP-like programming languages.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">It can also be applied to other languages with first-class functions, e.g. Python &amp; Ruby.<br />
<br />
</span></span> The explanation is actually very simple, LISP<sub>1</sub> has a single shared namespace for functions and variables. This means a symbol can refer to either a function or a variable, but not both. Consider the following Racket code:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(double x)
  (* <span class="dv">2</span> x))

(<span class="kw">define</span><span class="fu"> triple </span>(* <span class="dv">3</span> <span class="dv">4</span>))

double
<span class="co">;; =&gt; #&lt;procedure:double&gt;</span>

triple
<span class="co">;; =&gt; 12</span>

(double triple)
<span class="co">;; =&gt; 24</span></code></pre></div>
<p>When you resolve a symbol to a variable, you cannot know if it will resolve to a function or not.</p>
<p>LISP<sub>2</sub> on the other hand has a separate namespace for functions. This has the advantage that every name can be used twice,<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">I’m glossing over the fact that Common Lisp actually has more than two namespaces, depending on your definition of the term namespace.<br />
<br />
</span></span> once for a function, and once for a variable. The tradeoff is that the user has to specify in which namespace they want to resolve a symbol. Consider the following Emacs Lisp code:</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> double </span>(x)
  (<span class="op">*</span> <span class="dv">2</span> x))

(<span class="kw">defvar</span><span class="fu"> double </span>(<span class="op">*</span> <span class="dv">2</span> <span class="dv">4</span>))

(<span class="kw">funcall</span> #&#39;double double)
<span class="co">;; =&gt; (funcall &lt;function double&gt; &lt;variable double&gt;)</span>
<span class="co">;; =&gt; (double 6)</span>
<span class="co">;; =&gt; 12</span></code></pre></div>
<p>Note the added punctuation to denote the first <code>double</code> as a symbol resolving to a function.</p>
<h2 id="lispwhy">LISP<sub>why?</sub></h2>
<p>LISP is one of the oldest programming languages that is still used commercially today in some form, if you accept Common Lisp in its lineage. It appears that the namespace separation in the original LISP 1.5 was mostly incidental, and <a href="http://www.nhplace.com/kent/Papers/Technical-Issues.html">has been regretted since</a>.</p>
<p>The set of LISP<sub>2</sub> languages is quite small these days. Besides Common Lisp and Emacs Lisp, both of which are over three decades old at this point, there are also Ruby and Perl.<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Honourable mention: <a href="http://lfe.io/">Lisp Flavoured Erlang</a> is a LISP<sub>2</sub>.<br />
<br />
</span></span></p>
<p>The other ancient LISP-like language, Scheme, is a LISP<sub>1</sub>, and so is its popular modern dialect Racket (as demonstrated above). Almost every other somewhat popular language chooses to share a single namespace between functions and variables. Examples include Clojure, Janet, Python, Java, JavaScript, and even Rust.</p>
<p>Clearly the benefits of less syntactic clutter and cognitive overhead have won in the popular arena, to the point that the established de facto standard itself becomes a good reason to stick with a single unified namespace. Of course improvement, by its very definition, always requires change, but language designers need to be acutely aware of the cost incurred by diverging from the established norm.</p>]]></summary>
</entry>
<entry>
    <title>Literate Calculations in Emacs</title>
    <link href="https://sulami.github.io/posts/literate-calc-mode/index.html" />
    <id>https://sulami.github.io/posts/literate-calc-mode/index.html</id>
    <published>2020-05-21T00:00:00Z</published>
    <updated>2020-05-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It is no secret that I am a big fan of <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> for many use cases. I think it is a great match for investigative or exploratory notes, research, and <a href="https://github.com/sulami/dotfiles/blob/master/emacs/.emacs/README.org">configuration</a>.</p>
<p>On a Friday evening about two weeks ago, my flatmate came up with an idea for doing calculations in a literate way. Of course, if you really wanted to, you could use a <a href="https://jupyter.org/try">Jupyter Notebook</a>, but we were looking for something more lightweight, and ideally integrated into Emacs.</p>
<p>A quick search came up empty, so on Saturday morning I got started writing what came to be <a href="https://github.com/sulami/literate-calc-mode.el">Literate Calc Mode</a>. The features I wanted included named references to earlier results, spreadsheet-like recalculations on every change, and the ability to save my calculations to a file. And then of course the ability to interlace calculations with explanatory text.</p>
<p>It was in part inspired by the iOS app <a href="http://tydligapp.com/">Tydlig</a><span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote"><img src="/images/tydlig.png" title="fig:" alt="Screenshot of Tydlig" /><br />
<br />
</span></span>, which also provides calculations with automatically updating references to earlier results, but does not allow saving the workspaces as files, which I find very limiting.</p>
<p>But enough talk, this is what the result looks like in action:</p>
<div class="figure">
<video controls proload="none" alt="Demo Video">
<source src="/raw/literate-calc-demo.webm" type="video/webm">
</video>
</div>
<p>This is <code>literate-calc-minor-mode</code>, running alongside <code>org-mode</code>. As you can see, it automatically picks up calculations and inserts the results as overlays at the end of the line. It allows the user to bind results to variables, which can even have names with spaces. Any change causes all values to be recalculated, similar to a spreadsheet.</p>
<p>Because it uses Emacs’ built-in <code>calc-eval</code> behind the scenes, it supports almost everything <code>M-x calc</code> does, including formulas, complex units, and unresolved mathematical variables.</p>
<p>Of course there are also other convenience functions, such as evaluating just a single line, or inserting the results into the file for sharing. I do have some more plans for the future, which are outlined in the <a href="https://github.com/sulami/literate-calc-mode.el#roadmap">documentation</a>.</p>
<p>In addition to hopefully providing some value to other Emacs users, this was also a great learning experience.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">On a meta-level, writing this post has taught me how to use <code>&lt;video&gt;</code> on my blog.<br />
<br />
</span></span> I have learned a lot about overlays in Emacs, and I published my first package on <a href="https://melpa.org/">MELPA</a>, which was a thoroughly pleasant experience.</p>]]></summary>
</entry>
<entry>
    <title>The Grumpy Developer&#39;s Guide to Meetings</title>
    <link href="https://sulami.github.io/posts/engineers-meeting-guide/index.html" />
    <id>https://sulami.github.io/posts/engineers-meeting-guide/index.html</id>
    <published>2020-04-21T00:00:00Z</published>
    <updated>2020-04-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While everyone is writing about remote meetings these days, I do not believe that successful remote meetings are actually meaningfully different from successful in-person meetings.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I’m glossing over videoconferencing because I don’t believe it is a meaningful hurdle to clear.<br />
<br />
</span></span></p>
<p><a href="http://twitchard.github.io/posts/2020-03-28-against-process.html">Like many other developers</a>, I loathe meetings, especially when they seem like a waste of valuable time. My philosophy is “if you have to set up a meeting, at least do it right”. Consequently, here are some rules for successful meetings, both remote and in-person:</p>
<h2 id="the-best-meeting-is-no-meeting">The Best Meeting Is No Meeting</h2>
<p>It is important to understand the tradeoffs involved when deciding to schedule a meeting. Meetings are synchronous discussions, which makes them useful for knowledge exchanges and decision making processes, but they are also time-intensive and disruptive for everyone involved.</p>
<p>The alternative to organising a meeting is an asynchronous conversation, for example on a shared document.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">I find that doing all the same work as for a meeting on a shared document, but just leaving out the actual meeting, is a very effective way of using asynchronous process.<br />
<br />
</span></span> This can be faster than a meeting overall, as it allows participants to participate in their own time, instead of trying to find a slot that fits everyone. In addition to that, it is much less disruptive compared scheduling a meeting, especially for <a href="https://www.oreilly.com/library/view/changing-software-development/9780470515044/9780470515044_software_developers_are_knowledge_worker.html">knowledge workers</a>.</p>
<p>The only good reason for a synchronous meeting is making decisions requiring knowledge exchange and/or consensus. A good example would be planning a complicated feature, or cleaning up a backlog.</p>
<h2 id="the-most-important-work-happens-before-the-meeting">The Most Important Work Happens Before the Meeting</h2>
<p>Every meeting needs an organiser. The organiser needs to define the expected outcome of the meeting, as well as gather all required information, and share all of these in the meeting agenda. The outcome should be tangible, like a decision or a set of tasks to be done.</p>
<p>The agenda is crucial, because the participants will likely have to do some preparation in advance to the meeting. If any specific work needs to be done before the meeting, like research or data retrieval, make sure to clearly assign tasks.</p>
<p>I recommend writing out the full agenda before scheduling the meeting, and then sharing the agenda with the calendar invitation. This allows everyone to schedule their preparation in their own time.</p>
<h2 id="the-actual-meeting">The Actual Meeting</h2>
<p>During the meeting it is important to keep notes, usually in a shared document. You can designate a scribe, or just agree to all contribute some bullet points whenever possible.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Both approaches have pros and cons. A dedicated scribe leads to more detailed and coherent notes, but requires a person who will not be able to take part in the conversation, at least not effectively.<br />
<br />
</span></span> You want to write down any conclusions reached, important points made, and further questions and future work to be done. Do not care too much about form, the meeting organiser should rewrite the notes after the meeting anyway.</p>
<p>The meeting is prime talking time, and you should treat it as such. Do not spend time watching someone carry out a task.<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">There is really no point in everyone watching a single person manipulate a JIRA board during a meeting.<br />
<br />
</span></span> If you find during the meeting that you require more information, write this down as a future task instead of derailing the meeting.</p>
<p>The organiser should always work towards the defined outcome, but it often happens that some other discussion emerges as a precondition to reaching the outcome. There is a balance to be struck between discussion necessary to get to a meaningful outcome and veering too far off-topic.</p>
<p>Keep in mind that the time slot scheduled is more a rough guideline than a rule. If you can finish early, do so. If you need more time, and everyone involved has more time, take it.<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">Though maybe take a 5 minute break.<br />
<br />
</span></span> Do not try to force an outcome if you did not get there in time. If you find at the start of the meeting that some necessary precondition has not been met do not be afraid to reschedule or cancel altogether.</p>
<h2 id="the-alternative-the-ad-hoc-huddle">The Alternative: The Ad Hoc Huddle</h2>
<p>The rules above do not mean that you cannot talk to one another without ritual. Especially for small discussions between 2-4 people, ad hoc huddles can be useful.</p>
<p>As a rule of thumb, these should usually be happening within the next 24 hours, so usually “later today” or “tomorrow morning”.</p>
<p>You still need to define a goal, and you will want to write down any outcomes in some form, even if less formal than meeting notes. Even a Slack message with some findings in a relevant channel counts.</p>]]></summary>
</entry>
<entry>
    <title>Restarts in Common Lisp</title>
    <link href="https://sulami.github.io/posts/common-lisp-restarts/index.html" />
    <id>https://sulami.github.io/posts/common-lisp-restarts/index.html</id>
    <published>2020-04-01T00:00:00Z</published>
    <updated>2020-04-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em><strong>Errata:</strong> An earlier version of this post was misrepresenting conditions as exceptions, which has been addressed.</em></p>
<hr />
<p>I have been reading <em><a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a></em> by Peter Seibel over the weekend, which is an excellent introduction to Common Lisp, showcasing its power by writing real programs. If you are interested in Lisp or programming languages at all, I recommend at least skimming it, it is free to read online.</p>
<p>Writing a Lisp-descended language professionally, and also living inside Emacs, I had dabbled in Common Lisp before, but I still found something I was not aware of, restarts. I do not think that this is a particularly well known feature outside the Lisp world, so I would like to spread awareness, as I think it is a particularly interesting take on error handling.</p>
<p>The book explains restarts using a mocked parser, which I will slightly modify for my example. Imagine you are writing an interpreter/compiler for a language. On the lowest level you are parsing lines to some internal representation:</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">define-condition</span><span class="fu"> invalid-line-error </span>(<span class="kw">error</span>)
  ((line :initarg :line :reader line)))

(<span class="kw">defun</span><span class="fu"> parse-line </span>(line)
  (<span class="kw">if</span> (valid-line-p line)
      (to-ir line)
    (<span class="kw">error</span> &#39;invalid-line-error :line line)))</code></pre></div>
<p>We define a condition, which is similar to an exception object with metadata in other languages<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">A “condition” in Common Lisp, as has been explained to me by <a href="https://phoe.github.io">Michał “phoe” Herda</a>, is a way of signalling arbitrary events up the stack to allow running of additional code, not just signalling errors. They’re comparable to hooks in Emacs, but dynamically scoped to the current call stack.<br />
<br />
</span></span>, and a function which attempts to parse a single line.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">This is assuming of course that a line always represents a complete parsable entity, but this is only an example after all.<br />
<br />
</span></span> If it turns out that the line is invalid, it signals a condition up the stack. We attach the line encountered, in case we want to use it for error reporting.</p>
<p>Now imagine your parser is used in two situations: there is a compiler, and a REPL. For the compiler, you would like to abort at the first invalid line you encounter, which is what we are currently set up to do. But for the REPL, you would like to ignore the line and just continue with the next line.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">I’m not saying that is necessarily a good idea, but it is something some REPLs do, for example some Clojure REPLs.<br />
<br />
</span></span></p>
<p>To ignore a line, we would have to either do it on a low-level, return <code>nil</code> instead of signalling and filter out <code>nil</code> values up the stack. Handling the condition will not help us a lot, because at that point we have lost our position in the file already, or have we?</p>
<p>The next layer up is parsing a collection of lines:</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> parse-lines </span>(lines)
  (<span class="kw">loop</span> for line in lines
        for entry <span class="op">=</span> (<span class="kw">restart-case</span>
                     (parse-line line)
                     (skip-line () <span class="kw">nil</span>))
        <span class="kw">when</span> entry collect it))</code></pre></div>
<p>This is where the magic begins. The <code>loop</code> construct just loops over the lines, applies <code>parse-line</code> to every element of the list, and returns a list containing all results which are not <code>nil</code>. The feature I am showcasing in this post is <code>restart-case</code>. Think of it this way: it does <strong>not</strong> handle a condition, but when the stack starts unwinding <span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Technically not unwinding yet, at least not in Common Lisp.<br />
<br />
</span></span> because we signalled a condition in <code>parse-line</code>, it registers a possible restart-position. If the condition is handled at some point,<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">If it isn’t caught, you will get dropped into the debugger, which also gives you the option to restart.<br />
<br />
</span></span> the signal handler can choose to restart at any restart-point that has been registered down the stack.</p>
<p>Now let us have a look at the callers:</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> parse-compile </span>(lines)
  (<span class="kw">handler-case</span>
      (parse-lines lines)
    (invalid-line-error (e)
                        (print-error e))))

(<span class="kw">defun</span><span class="fu"> parse-repl </span>(lines)
  (<span class="kw">handler-bind</span> ((invalid-line-error
                  #&#39;(<span class="kw">lambda</span> (e)
                      (<span class="kw">invoke-restart</span> &#39;skip-line))))
    (parse-lines lines)))</code></pre></div>
<p>There is a lot to unpack here. The compiler code is using <code>handler-case</code>, which is comparable to <code>catch</code> in other languages. It unwinds the stack to the current point and runs the signal handling code, in this case <code>print-error</code>.</p>
<p>Because we do not actually want to unwind the stack all the way, but resume execution inside the <code>loop</code> in <code>parse-lines</code>, we use a different construct, <code>handler-bind</code>, which automatically handles <code>invalid-line-error</code> and invokes the <code>skip-line</code> restart. If you scroll up to <code>parse-lines</code> now, you will see that the restart clause says, if we restart here, just return <code>nil</code>, and <code>nil</code> will be filtered on the very next line by <code>when entry</code>.</p>
<p>The elegance here is the split of signal handling code, and decisions about which signal handling approach to take. You can register a lot of different <code>restart-case</code> statements throughout the stack, and let the caller decide if some signals are okay to ignore, without the caller having to have intricate knowledge of the lower-level code.<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">It does need to know about the registered <code>restart-case</code> statements though, at least by name.<br />
<br />
</span></span></p>
<p>If you want to learn more about this, make sure to have a look at the book, it goes into much more detail than I did here.</p>]]></summary>
</entry>
<entry>
    <title>How to Read a Book</title>
    <link href="https://sulami.github.io/posts/how-to-read-a-book/index.html" />
    <id>https://sulami.github.io/posts/how-to-read-a-book/index.html</id>
    <published>2020-03-14T00:00:00Z</published>
    <updated>2020-03-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A while ago I read <em><a href="https://www.goodreads.com/book/show/567610.How_to_Read_a_Book">How to Read a Book</a></em>, the guide to extracting information from non-fiction books first published in 1940. Like many older books, there are parts of it that haven’t aged well, and in a particularly ironic fashion the book is quite verbose. I thought it might be useful to compile a short and simple step-by-step guide to efficiently reading non-fiction.</p>
<p>Imagine a book as an object with two dimensions: scope and detail. If you read the entire book cover to cover, you will learn about the full scope covered, in the level of detail of the book.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Well, not really. Performing a single, cover to cover reading usually does not suffice to extract everything from a book.<br />
<br />
</span></span> But many books are several hundred pages long, and active reading demands attention and energy.</p>
<p>You can compromise on either of those dimensions (or both). If you just read the first half of the book, you are compromising on scope, as there is a whole second half of the subject you did not cover at all. If instead you want to compromise on detail, you should read “outside-in”, starting with strategic skimming and delving in deeper afterwards.</p>
<p>Start by getting a vague idea of everything covered in the book, going more and more into detail at each step. At any step you can stop and decide if the next level of details is worth the additional time required, but the knowledge you have extracted at that point is likely more useful than if you had compromised on scope.</p>
<p>The outside-in method is also useful for picking out books to read at a bookstore, as you can just start with the first few steps right there, and buy the book if you want to continue.</p>
<p>Simply follow these steps below, as long as you feel like gaining deeper understanding is worth the additional time. Ideally you want to have a way of taking notes, both to capture sections or topics to investigate further, but also to aid active reading.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Active reading is one of these barely defined terms, but what I’m trying to express is the notion of thinking about the text as you read it, and actively trying to take in information. I might publish a piece on note-taking in the future.<br />
<br />
</span></span></p>
<ol>
<li>Read the back cover, and any other summaries and publisher blurbs.</li>
<li>Read the table of contents, note the scope and structure. Identify the important and pivotal chapters.</li>
<li>Read the preface.</li>
<li>Scan the index and references for anything interesting to look at, both inside and outside this book.</li>
<li>Read the opening and closing parts of the pivotal chapters, usually about a page each.</li>
<li>Read the final part of the book containing content, such as a conclusion chapter or section.</li>
<li>Pick a handful of random sections throughout the whole book and read a page or two each.</li>
</ol>
<p>At this point you should have spent between 30 minutes and one hour, and have answers to these questions:</p>
<ul>
<li>What is the book about, and which scope does it cover?</li>
<li>Are there any additional topics or works to investigate outside of its scope?</li>
<li>Which conclusions or opinions does it offer?</li>
</ul>
<p>The last question is particularly important if you want to continue, as it sets the context of this book in comparison to others covering the same subject. Authors have different backgrounds and biases, which colour their works.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">A good example is David Allen’s <em><a href="https://www.goodreads.com/book/show/1633.Getting_Things_Done">Getting Things Done</a></em>, which does hold some value for everyone, like the notion of the task inbox, but also contains a lot of absurd examples and use-cases which clearly show the kind of life he’s living, and the priorities he has.<br />
<br />
</span></span></p>
<p>The more thorough levels of reading take a lot more time, but can be useful if you want to get a deeper understanding of the subject. There are two more steps you can take to gain more insight:</p>
<ol>
<li>Continue reading the chapters, actually reading entire chapters now.</li>
<li>Use other works covering the same subject and cross-reference the important points as you come across them. This allows you to get different viewpoints on the individual points.<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">This is what Adler calls “syntopical” reading, which is a whole discipline on its own. I won’t cover it here, but you can find plenty of material online, and How to Read a Book also has a more detailed explanation.<br />
<br />
</span></span></li>
</ol>
<p>If you get this deep into a subject, the first few steps will be very quick to perform, as you are already familiar with the subject, so you only need to find answers to the questions above before delving in deeper.</p>]]></summary>
</entry>
<entry>
    <title>Why I like Clojure</title>
    <link href="https://sulami.github.io/posts/why-i-like-clojure/index.html" />
    <id>https://sulami.github.io/posts/why-i-like-clojure/index.html</id>
    <published>2019-08-30T00:00:00Z</published>
    <updated>2019-08-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is somewhat of a response to Uncle Bob’s <a href="http://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html">post of similar nature</a>, which I would say has gotten a mixed to positive reception. I had planned a similar post a week or two before the release of his, but archived the idea upon reading his post. But after having read it over a couple of times I have now decided that I still have something meaningful to write. What follows are the purely subjective reasons for which <em>I</em> enjoy using Clojure. Some have criticised Bob for being very absolute and not giving up any screen estate for more nuanced viewpoints, something I will try to avoid.</p>
<h2 id="lisp">Lisp</h2>
<p>There is not much to say about this that has not already been said. The homoiconicity, meaning code can be represented as a data structure inside the same language, extensibility through macros which can modify both the evaluation order as well as the very syntax to the point where <a href="https://docs.racket-lang.org/scribble/getting-started.html">it looks more like LaTeX than Lisp</a>.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Racket is actually a great example of the flexibility of Lisp. A language designed to build other languages in it, call it a meta-language. Even package import can be wrapped up in a “language” trivially, meaning that you can essentially write a tiny DSL for every project. Not saying that is necessarily a good idea, but you can.<br />
<br />
</span></span></p>
<p>This also means that you are not stuck with a paradigm. While OO seems to be out, and FP the new hotness, Lisp can do them all, and historically often did before anyone else. Bob mentions dynamic typing in his signature retorts to (I am guessing) fictional counter-arguments, and he is right to mention <a href="https://clojure.org/guides/spec"><code>clojure.spec</code></a>, a library for gradual typing (omitting <a href="https://github.com/plumatic/schema"><code>schema</code></a>, an alternative). Racket has a <a href="https://docs.racket-lang.org/ts-guide/quick.html">fully typed variant</a>, there is something that is basically <a href="https://shen-language.github.io">Haskell in a Lisp-bun</a>, and let us not forget that there is actually <a href="https://github.com/clojure/core.typed">Typed Clojure</a>, with static type checking and all.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">There are some issues with it, namely that the coverage is not all that great, but it exists and works, meaning if you really <em>need</em> static types, you can get them.<br />
<br />
</span></span></p>
<p>Being able to generate code without being stuck on a “dumb” level by generating strings and passing them into <code>eval</code> like for example in Python allows for sane hyper-dynamic programming, where the program adapts itself to the conditions. Being able to read and write code in a safe manner enables extremely powerful tooling in the Lisp world. Linters are very smart, because <a href="https://github.com/xsc/rewrite-clj">reading code into a data structure is trivial</a>, usually a one-liner, and there are many more tools to automatically rewrite and refactor code than for other languages.</p>
<p>Now I do not want to discount the <a href="http://winestockwebdesign.com/Essays/Lisp_Curse.html">Lisp Curse</a>, it is a real thing, and one of the reasons that while Lisp has stuck around for over half a century, it has not made it into the mainstream. The other main factor probably being the performance problems due to the gap between software and hardware architecture.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">There were Lisp machines, which had hardware tailored towards running Lisp, but they never took off either.<br />
<br />
</span></span> But with the advent of the internet, ecosystems like GitHub, and hardware that is fast enough that we consider running basically full web browsers for half of our applications<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Looking at you, Slack.<br />
<br />
</span></span>, I think that these issues have become surmountable.</p>
<p>I do not think I need to mention how incredibly useful the REPL and hot-loading code into a running system are?</p>
<h2 id="hosted">Hosted</h2>
<p>Clojure is explicitly designed as a hosted language, which I think was a very good move. If you are writing a new language today, it might be better than the established ones, but the cost of leaving an existing ecosystem of libraries and Stack Overflow answers just because the new language is 5% nicer is not a trade off many people will want to make. Clojure being hosted and having excellent interoperability with its host platform means it can benefit from existing ecosystem, let alone platform implementations.<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">Do you really want to implement your runtime for FreeBSD on a smart toaster oven? Raspberry Pis are non x86, BSD is not Linux, and who knows what is up with Windows. This matrix is growing quickly.<br />
<br />
</span></span></p>
<p>While the primary platform is the JVM, superbly uncool but stable and relatively performant, there is a CLR (.NET) version which is “almost even on features” thanks to Davit Miller, as well as a very mature JavaScript version in the shape of ClojureScript. The JVM (and to some extent the CLR) have excellent support by big software vendors, if you buy some kind of software with an API, chances are there is a Java SDK which you can use easily from your Clojure code. The JavaScript ecosystem is the largest in numbers<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">In part due to left-pad-like five-line-packages, but still.<br />
<br />
</span></span>, and includes Electron and React-Native, both of which can be used with some, but not unreasonable, effort from ClojureScript code. One of the newest additions has been GraalVM, which while not 100% feature-complete yet, already allows compilation to native static binaries of many Clojure programs<span><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span class="sidenote"><a href="https://github.com/kkinnear/zprint">Zprint</a> is one of those CLI tools that takes advantage of the reduced startup time.<br />
<br />
</span></span>, running without the JVM at all, and doing away with the dreaded multi-second startup time.<span><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span class="sidenote">I am planning to write a piece about GraalVM some time later this year.<br />
<br />
</span></span></p>
<p>The platform split could have been one of the big, curse-like problems for Clojure, but there is Clojure Common, used by many popular libraries, which allows you to write platform-independent code by using conditional branching for all platform-specific code.</p>
<h2 id="community">Community</h2>
<p>Despite all the positive points I mentioned, Clojure is still a niche language, and in some way that is good as well. Sure, finding jobs is harder<span><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span class="sidenote">Large companies like Walmart and CircleCI (my employer) are Clojure shops, so it is far less obscure than one might think.<br />
<br />
</span></span>, but not impossible. Clojure developers, like for example Haskell or Rust ones, tend to be more experienced, as it is not a typical first language, and requires a certain interest in the craft. Many Clojure developers have written widely used tools and libraries, not just in Clojure, but also for example for Emacs, which is understandably quite popular with Clojurists.</p>
<p>Rich Hickey himself, the BDFL of Clojure, is someone with decades of industry experience and a desire to get it right. I think he is doing a pretty good job. While there are some small inconsistencies in places, the bulk of the language, and all the important parts are very well thought out.<span><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span class="sidenote">We can also see right now how <code>clojure.spec</code> is being adapted after community feedback to the first alpha version, which has been available for about 1½ years.<br />
<br />
</span></span> Clojure is a very stable language, which means that smaller problems will stick around for a while, but also means you can trust that your code will not break every time you update your dependencies.</p>
<p>In the end, it comes down to enjoyment. I enjoy working with Clojure. I feel like there is a lot to learn, and the language is inviting me to explore beyond the current possibilities of software development. I feel good about the elegant and concise solutions<span><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span class="sidenote">concise ≠ obtuse<br />
<br />
</span></span> I can come up with. It has changed the way I think, in a good way.</p>]]></summary>
</entry>
<entry>
    <title>My Thoughts on spec</title>
    <link href="https://sulami.github.io/posts/my-thoughts-on-spec/index.html" />
    <id>https://sulami.github.io/posts/my-thoughts-on-spec/index.html</id>
    <published>2019-07-01T00:00:00Z</published>
    <updated>2019-07-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the beginning of this year I started a new job, and I am now fortunate enough to be writing <a href="https://clojure.org">Clojure</a> full-time. I believe that Clojure is a very well crafted language and enables developers like few others, but I have also some grievances to report. I want to prefix this by saying that I love Clojure despite its faults, and this is more of a constructive criticism piece than anything else.</p>
<h2 id="what-is-spec">What Is spec?</h2>
<p>What I want to discuss today is <a href="https://clojure.org/guides/spec"><code>clojure.spec</code></a>, the gradual typing solution shipped with Clojure since 1.9.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I am of course aware that spec is officially in alpha, and that there is a second alpha version which might address some of my points here. But as I have not tried alpha 2 yet, and a lot of people are using alpha 1, we will be mostly looking at alpha 1 in this post. Still, feel free to contact me and tell me how alpha 2 will improve things.<br />
<br />
</span></span> In case you are not familiar with spec, here is a quick run-down of how it works:</p>
<p>Clojure is a dynamically typed language, meaning no (or very few) type annotations in the source code, unlike say Haskell or most curl-brace languages. While this removes a lot of visual clutter, and the language is designed in such a way that most functions can operate on most types for maximum flexibility, this also means that sometimes things break at run time due to type errors. To make dealing with types easier, spec allows you to place type definitions in strategic places, say at entry- and exit points of an app or a module to ensure that your idea of structure and type of your data still lines up with reality.</p>
<p>The benefit of this approach over static typing is that you can encapsulate parts of your software with type safety without having to deal with the encumbrance in the internals. You define a contract to the outside, but stay flexible in your implementation.</p>
<p>In practice it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> spec-demo
  (<span class="at">:require</span> [clojure.spec.alpha <span class="at">:as</span> s]
            [clojure.spec.gen.alpha <span class="at">:as</span> gen]))

(s/def <span class="at">::name</span> <span class="kw">string?</span>)
(s/def <span class="at">::age</span> pos-int?)

(s/def <span class="at">::person</span>
  (s/keys <span class="at">:req-un</span> [<span class="at">::name</span>
                   <span class="at">::age</span>]))

(s/valid? <span class="at">::person</span>
          {<span class="at">:name</span> <span class="st">&quot;John&quot;</span>
           <span class="at">:age</span> <span class="dv">35</span>})
<span class="co">;; =&gt; true</span>

(s/explain <span class="at">::person</span>
           {<span class="at">:name</span> <span class="dv">35</span>})
<span class="co">;; =&gt; 35 - failed: string? in: [name] at: [:name] spec: :spec-demo/name</span>
<span class="co">;;    {:name 35} - failed: (contains? % :age) spec: :spec-demo/person</span>

(gen/generate
  (s/gen <span class="at">::person</span>))
<span class="co">;; =&gt; {:name &quot;3o311eSXA4Dm9cLkENIt3J5Gb&quot;, :age 3318}</span></code></pre></div>
<p>This snippet demonstrates creating a spec <code>person</code> which has sub-specs <code>name</code> and <code>age</code>, validates some data against the spec, explains why some data does not validate, and also generates some random data compliant with the spec. The last bit is incredibly useful for testing, as you can imagine. There are some more advanced features than what I have shown here, like specs for in- and output types of functions, but this is the gist of it.</p>
<h2 id="so-what-is-wrong-with-spec">So What Is Wrong with spec?</h2>
<h3 id="specs-as-macros">specs as Macros</h3>
<p>spec is implemented using macros, which are compile-time expansions, think template meta-programming in C++. This brings some limitations, which are especially noticeable in Clojure where, like in most other Lisps, code is treated as data and many parts of your software are introspectable at run time. specs are, once defined, not easy to extract data from.</p>
<p>Contrast this with <a href="https://github.com/plumatic/schema">schema</a>, a Clojure library which does essentially the same thing, and got started before spec. schema “schemas” are just hash maps, which are easily constructed and introspected at run time. schema has other problems, but the community seems to generally flock to spec as the officially blessed version.</p>
<p>The situation I have now repeatedly seen is one where I have a spec defining a specific representation of an entity, where for example one spec extends another one. A practical example here is when augmenting an entity with additional data, so that the output representation is a modified version of the input type.</p>
<p>You can define a spec as a superset of another spec, and only in that direction, using <code>s/or</code>, but at that point you are already stuck in the spec an cannot get the list of fields easily out of your specs. It would be nice to be able to define one spec in terms of flat data, which would also be available at run time. This would be incredibly helpful for use with something like <code>select-keys</code>.</p>
<p>There are ways of working around this, for example by using <code>eval</code>, or wrapping your spec macros in another layer of macros, but both of these are more hacks than solutions. <a href="https://github.com/clojure/spec-alpha2/wiki/Differences-from-spec.alpha">spec alpha 2</a> promises to solve this particular problem by separating symbolic specs from spec objects, the former being just flat data which can also be generated programmatically.</p>
<p>If spec alpha 2 works out the way I hope, this will be solved soon, and the documentation looks promising so far.</p>
<h3 id="namespacing">Namespacing</h3>
<p>spec is very intent on you using namespaces for your keywords, which in general is a good idea. Many developers, including myself, have been using the namespace of a key to give context about its use, for example <code>:person/name</code> is a different spec from <code>:company/name</code>. The problem with this is the overloading of namespaced keywords, which are an existing Clojure feature. These namespaces <code>person</code> and <code>company</code> do not actually exist, and I do not want to clutter all my keys with a long prefix like <code>:myapp.entities.person/name</code> to make it match a real namespace.</p>
<p>Now namespaced keywords can have any namespace, and the namespace does not actually have to exist for everything related to keywords to work well, except when it does. If you want to use a spec from another namespace, but <code>alias</code> that namespace to shorten it, you need to <code>require</code> that namespace, for which it needs to exist. As a workaround to this I have created “fake” namespaces in the past using a helper.</p>
<p>This actually leads me to another problem, which is the question of where to place specs in the first place. spec comes with a global, centralised registry for specs, which in alpha 1 you cannot opt out of. In theory this allows you to define/register your spec once in any place you like, and then access it from anywhere without having to know where it comes from or requiring it. This, while having the potential for being too opaque and magical, is actually a very good feature in my opinion. It is trivial to override specs when reloading them, and I have not experienced any issues with evaluation order yet. Due to specs referring to other specs by their name, you can define dependencies of a spec after the fact, and the system will pick them up accordingly.</p>
<p>My current solution for this is having a file &amp; namespace for every entity which can be required and aliased normally, the only problem with this being relationships between specs. As soon as one spec needs to include another spec, dependencies get muddled, so I have experimented with having a special namespace for specs which are shared across many other specs, but this is far from ideal. I wish there was a cleaner way to do this, especially leveraging the global registry.</p>
<h3 id="function-spec-definitions">Function spec Definitions</h3>
<p>I mentioned above that spec also allows instrumenting functions, but the semantics for this are a bit wonky in my opinion. See for yourself:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> double </span>[x]
  (<span class="kw">*</span> <span class="dv">2</span> x))

(s/fdef <span class="kw">double</span>
  <span class="at">:args</span> (s/cat <span class="at">:x</span> int?)
  <span class="at">:ret</span> int?
  <span class="at">:fn</span> #(<span class="kw">=</span> (<span class="at">:ret</span> %)
          (<span class="kw">-&gt;</span> % <span class="at">:args</span> <span class="at">:x</span> (<span class="kw">*</span> <span class="dv">2</span>))))</code></pre></div>
<p>This naive spec restricts in- and output types to integers, which is okay in this case. The <code>:fn</code> key describes the relationship between in- and output, and is in this case actually absurdly strict, but this is just an example. There are two issues I have with this:</p>
<p>First the <code>:fn</code> definition tends to be very elaborate and hard to understand at a glance. Even in this simple case, there is a lot going on in there, and the use of anonymous functions does not help it. In practice, this key is optional and I omit it almost always, because I cannot think of any formal assertions I want to make about the output which are also reasonably simple to encode. And if you want to make several separate assertions about the output, you almost cannot avoid breaking up the spec into pieces, at which point you have predicates which exist purely for spec.</p>
<p>The other issue I have is that this is decoupled from the actual function definition. In theory you can place the spec in a different namespace and refer to the function using its fully qualified name, and this is tempting, especially when looking at my previous point about these specs having the potential to be far more longer than the actual function definitions. But then your function exists conceptually in two places, and these two places have to be kept in sync. If you move, rename, or modify the function in almost any way, you have to modify the spec, too, but first you have to find the spec.</p>
<p>The problem I can see with this is that <code>:fn</code> can be used to make assertions about the functions, which can in almost all cases be made in unit tests as well. In fact, unit tests are meant for exactly this, asserting single assumptions about units at a time. The condition above could just as well be a test called <code>the result equals twice the input value</code>. Functions are usually only instrumented locally and/or during testing, as they incur non-negligible overhead, and I would argue that they do not provide significant assurances over unit tests.</p>
<p>I would much rather drop the <code>:fn</code> key, and include type declarations in the actual function definition, which is incidentally how schema works:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(s/defn <span class="kw">double</span> <span class="at">:-</span> s/Int
  [x <span class="at">:-</span> s/Int]
  (<span class="kw">*</span> <span class="dv">2</span> x))</code></pre></div>
<p>In the end, I am looking forward to the next iteration of spec, and hope it addresses as many issues as possible, and I am already blown away by how much better it is than alternatives available in other languages.</p>]]></summary>
</entry>
<entry>
    <title>Building a Literal Library of Building Blocks</title>
    <link href="https://sulami.github.io/posts/building-a-literal-library-of-building-blocks/index.html" />
    <id>https://sulami.github.io/posts/building-a-literal-library-of-building-blocks/index.html</id>
    <published>2019-02-02T00:00:00Z</published>
    <updated>2019-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">I know, insert the obligatory “I haven’t posted in a while” bit here.<br />
<br />
</span></span> is heavily inspired by <a href="https://soundcloud.com/defn-771544745/30-zach-tellman-aka-ztellman">a remark Zach Tellman made on the defn podcast</a>, where he says:</p>
<blockquote>
<p>Having been a professional programmer for a decade, I have a decade’s worth of experience at writing stuff from scratch, not a decade’s worth of tools in my toolbox. And that seems like a not optimal set of circumstances. <em>[Quote at 57:45]</em></p>
</blockquote>
<p>I have listened to this some time around Christmas, and this quote has kept me thinking over the past couple of months. What Zach is talking about is a project he is working on which would allow you to capture explorative programming in the branching fashion in which it happens. His example revolves around using a shell to perform some work, like extracting some specific values from a file.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">You should really go and listen to the episode, he has a lot of very great insights.<br />
<br />
</span></span> He explains how we work out these sequences of commands that to accomplish our goal, but never generalise them, but instead throw them away, just to write them from scratch the next time we encounter a similar problem. This rings true for all kinds of programming, not just shell scripting, though shell scripts are especially susceptible to this.</p>
<p>Like Zach, I believe this to be a suboptimal situation. Especially being a functional programmer, I believe in small, abstract building blocks, composition, and code reuse, rather than overly specific, bespoke solutions that have to be written from scratch every time. I am someone who tinkers a lot, and there is a lot of code I never commit anywhere. As a matter of fact, I have a habit of creating throw-away files or whole projects in <code>/tmp</code> just to play with something for anywhere between five minutes and a weekend. At the same time I also have a repository on my Github literally called playground, which contains all kinds of small things that I did not want to go through the hassle of creating a Github repository for.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Interesting aside: while creating a local repository has so little friction that I do it all the time, only a fraction of them ever touch Github’s servers, as creating a repository through the web interface incurs so much friction.<br />
<br />
</span></span></p>
<p>This repository has allowed me to cannibalise some snippets of codes I used in the past, but it is not what I would call a comprehensive library of generalised solutions to problems I repeatedly face. And that has been hugely helpful already, for example I have written about path-finding using the A* algorithm before, so I had a working implementation ready when I needed it for another project.</p>
<p>Having a library, in the worldly sense of the word, of useful, generalised snippets of code would institutionalise the knowledge of them. You would not have to remember how to invert a binary tree, because if you have ever played with binary trees you would already have an implementation handy, and it would be tried and tested, and performance-optimised.</p>
<h2 id="practical-implementations">Practical Implementations</h2>
<p>Having arrived at the decision of generalising and collecting useful snippets of code somewhere, we are now facing the question of where somewhere actually is, and how we distribute the snippets in a way that allows us to easily use them.</p>
<p>The simplest solution would be to maintain one or several collections of useful snippets, and just copy-pasting them into the code you are writing. While this is fast and simple, it does not facilitate innovation flowing in either direction. Updates to the generalised versions are not included in downstream products using them, and vice versa. The result would likely be a duplication of similar, but subtly different solutions to all kinds of problems, scattered over various projects. Bugs that have long been fixed in one of them might still be present in others.</p>
<p>The alternative solution is packaging your snippets, and using them as a library. Most of the practical implementation will depend on the programming language you are using, and what kind of projects you are usually working on. Zach Tellman himself has a Clojure library called <a href="https://github.com/ztellman/potemkin">Potemkin</a>, which is a collection of “some ideas which are almost good”, and which he uses as a dependency for most of his other libraries.</p>
<p>While this incurs some overhead, namely the packaging of the library, it does come with a lot of advantages. Other people can benefit from your library. Depending on the scale of the overhead involved with building a library, splitting snippets by topic into “actual” libraries might make sense. It does require more abstraction, and more documentation, but that is not a bad thing. For a simple library with a handful of data structures or functions, writing a quick readme and some docstrings takes less than an hour.</p>
<p>There is still room for a default, catch-all library that is just for personal use and contains miscellaneous snippets without any particular topic, and it can be where new snippets end up first. If a section of it grows large enough, it can be extracted into its own library. The bottom line here is, if you write something that solves a problem, keep it somewhere, ideally where you can find it again. Even if it is not generalised or documented, it might come in handy in the future.</p>]]></summary>
</entry>
<entry>
    <title>Genetic Programming in Clojure</title>
    <link href="https://sulami.github.io/posts/genetic-programming-in-clojure/index.html" />
    <id>https://sulami.github.io/posts/genetic-programming-in-clojure/index.html</id>
    <published>2018-11-17T00:00:00Z</published>
    <updated>2018-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="the-theory">The Theory</h2>
<p>Like most programmers I have always had a vague interest in AI, and one of its branches that requires less complicated maths than recurrent neural networks which are the most well known one, is genetic programming. The idea of genetic programming is quite simple<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">If you are into more visual examples, this I believe is a very good practical example: <a href="http://rednuht.org/genetic_cars_2/" class="uri">http://rednuht.org/genetic_cars_2/</a><br />
<br />
</span></span>:</p>
<ol>
<li>You build something that is parameterised in key places</li>
<li>You build a scoring function to assess the performance of your something with a set of parameters</li>
<li>You randomly adjust (mutate) your parameters in some way a couple of times and compare the score of each set</li>
<li>You take the best one or ones as a base to start a new round of mutations and scoring</li>
<li>Basically just repeat steps 3 &amp; 4 for a while and your parameters will tend towards a maximum score</li>
</ol>
<p>Depending on a variety of meta-parameters that control for example the size of each generation or the nature of the mutations you might just find a local maximum, but often times this can yield pretty good results for a variety of problems.</p>
<h2 id="the-practice">The Practice</h2>
<p>I have toyed around with this over the last couple of days and built an very simple abstract implementation in Clojure, which I am going to share here (and eventually will be somewhere on Github as well). Let us explore it from the inside out.</p>
<p>First of all we need to be able to generate some mutations of our specimen. Because we do not assume anything about the specimen, this ends up being quite simple because a lot of the heavy lifting is done outside of this implementation as it is specific to the problem in question.</p>
<p>This returns a potentially infinite list containing first the specimen passed in, and then as many mutations of it as we want.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> mutate</span>
  <span class="st">&quot;Generator that mutates a base, the first element being the base.&quot;</span>
  [base mutator]
  (<span class="kw">concat</span> [base]
          (<span class="kw">repeatedly</span> #(mutator base))))</code></pre></div>
<p>Next we also need to be able to score it. In this case we would like to attach the scores to the specimens so that we can use them to sort and select specimens without losing the specimens themselves.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> attach-score</span>
  <span class="st">&quot;Attaches the score to a specimen.&quot;</span>
  [score-fn specimen]
  [specimen (score-fn specimen)])</code></pre></div>
<p>Now let us begin to tie these together. A single generation should take a base specimen, mutate it a couple of times, score each of them, and then select the “fittest” based on the scores<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">This also only keeps the best specimen in every generation, which makes the code much simpler. For actual real world usage it might be beneficial to keep the best <code>n</code> specimens in every generation to avoid running into local maxima. This would make the mutation slightly more complex though because there would be several base specimens which need to be mutated, so I decided to leave out this feature for the purposes of explanation.<br />
<br />
</span></span>. Note that in this implementation a lower score is better. To change this just reverse the sorting.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> generation</span>
  <span class="st">&quot;Picks out the best one from a generation.&quot;</span>
  [base mutator score-fn gen-size]
  (<span class="kw">-&gt;&gt;</span> (mutate base mutator)
       (<span class="kw">take</span> gen-size)
       (<span class="kw">map</span> (<span class="kw">partial</span> attach-score score-fn))
       (<span class="kw">sort-by</span> <span class="kw">second</span>)
       <span class="kw">first</span>
       <span class="kw">first</span>))</code></pre></div>
<p>And to finish off, we just need to run a number of generations, each based on the previous one’s winner.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> evolution</span>
  <span class="st">&quot;Generator for generations.&quot;</span>
  [base mutator score-fn gen-size]
  (<span class="kw">iterate</span> #(generation % mutator score-fn gen-size) base))</code></pre></div>
<p>The lazy nature of this implementation is allows us to inspect intermediate results easily, as we can see the path evolution has taken in the form of each generation’s winner.</p>
<h2 id="the-actual-practice">The Actual Practice</h2>
<p>Now this above is actually not that much code, and it is very abstract in its nature, so let us have a look at what it looks like when we actually use it. A simple example would be approximating a single number that is hard to approximate, like √2.</p>
<p>Our specimen is just a float, and any will do as the initial seed. It is itself the only parameter.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> base </span><span class="fl">0.0</span>)</code></pre></div>
<p>To mutate it, we just adjust it by a random amount within <code>0.5</code> in either direction.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> mutator </span>[base]
  (<span class="kw">-&gt;</span> (<span class="kw">rand</span>)
      (<span class="kw">-</span> <span class="fl">0.5</span>)
      (<span class="kw">+</span> base)))</code></pre></div>
<p>Our scoring function is cheating a little, because we already know the target, we can just compare against it and use the distance as the score.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">defn</span><span class="fu"> score-fn </span>[x]
  (<span class="kw">-&gt;</span> x
      (<span class="kw">-</span> (Math/sqrt <span class="dv">2</span>))
      Math/abs))</code></pre></div>
<p>Now when we run this, we can see how it approximates the target value over time (<code>√2 ≈ 1.4142</code>).</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">take</span> <span class="dv">6</span> (evolution base mutator score-fn <span class="dv">25</span>))
<span class="co">;; =&gt; (0.0</span>
<span class="co">;;     0.33079046010191426</span>
<span class="co">;;     0.7509224756253191</span>
<span class="co">;;     1.2164225056336746</span>
<span class="co">;;     1.3768753691848903</span>
<span class="co">;;     1.4125030676422798)</span></code></pre></div>
<p>Because <code>evolution</code> returns an infinite sequence, we can just use <code>nth</code> on it to get the winner after a certain number of generations.</p>
<p>While this is a very simple example, I am currently working on a way of using this to build and mutate a Clojure <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> and score it by running a series of unit tests against the generated code. If this works out I might write about it here soon.</p>]]></summary>
</entry>
<entry>
    <title>Working remotely (Part 2)</title>
    <link href="https://sulami.github.io/posts/working-remotely-part-two/index.html" />
    <id>https://sulami.github.io/posts/working-remotely-part-two/index.html</id>
    <published>2018-11-05T00:00:00Z</published>
    <updated>2018-11-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It has now been 48 days since the first part of this post, and 42 days since I moved into my current flat in Amsterdam. Time for me to write the promised follow-up and explain what has happened so far and how things have been going.</p>
<h2 id="the-good">The Good</h2>
<p>First of all, I am a lot happier in my personal life, moving was definitely the right decision for me in general, all work things aside. Having made the step into a remote agreement frees me up to move when- and wherever I want, as my employer does not care about from where I actually work at this point, apart from timezone-related concerns.</p>
<p>I also think that full control over my workspace can drastically improve my productivity, the main benefit being the lack of distractions.</p>
<p>Last time I mentioned that I would go back to London once a month. So far I am keeping to this schedule, and my first visit has been quite pleasant, even if a little stressful. But being able see my team members in person, catching up and meeting new hires allows us to stay more in touch. My only minor complaint is that travel is quite a hassle, especially at this rate, so I might try to turn down the frequency a bit.</p>
<h2 id="the-bad">The Bad</h2>
<p>After the moving process, which included being legally homeless for a weekend in France, I was quite happy to be able to stay home for a bit, so I ended up working from my living room for a couple of weeks. In addition to that, coworking spaces are (to me) surprisingly expensive for what they are.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">200€/mo. for something they call “a desk” but in reality is just a slot at a table, electricity, wifi and access to a kitchen with free coffee is quite a lot in my opinion. If I wanted an actual desk and office chair, ideally with a set of walls around it, I can expect to pay at least twice that.<br />
<br />
</span></span> But after a while I started suffering from both cabin fever and loneliness, so I bit the bullet and subscribed to one. This also ended up being the right decision, because just the way I wrote the last time, I have a physical location I can go to to work, but it is purely optional.</p>
<p>In addition to potential extra costs and stress due to more traveling, some employers also seem to think that remote workers should by default earn less than the ones coming into the office. It is true that remote work in and of itself can be seen as a perk, but I also believe that correctly executed remote work is beneficial to everyone involved.</p>
<h2 id="closing-notes">Closing Notes</h2>
<p>If you want to go remote I recommend you do what I (we) did and get a remote working agreement that is signed by you and your employer. It should capture the terms of the remote work, such as work hours, visits, who pays for transport and how long much in advance a warning needs to be given for you to be called into the office.</p>
<p>The last point is quite important especially if you are expected to pay for transport (and possibly lodging) which can be much more expensive if booked spontaneously.</p>]]></summary>
</entry>

</feed>
