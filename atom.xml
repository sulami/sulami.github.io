<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>sulami's blog</title>
    <link href="https://sulami.github.io/atom.xml" rel="self" />
    <link href="https://sulami.github.io" />
    <id>https://sulami.github.io/atom.xml</id>
    <author>
        <name>Robin Schroer</name>
        <email>sulami@peerwire.org</email>
    </author>
    <updated>2017-11-11T00:00:00Z</updated>
    <entry>
    <title>Hello, World! Again!</title>
    <link href="https://sulami.github.io/posts/hello-world-again/index.html" />
    <id>https://sulami.github.io/posts/hello-world-again/index.html</id>
    <published>2017-11-11T00:00:00Z</published>
    <updated>2017-11-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First of all, I know it has been quite silent on here for a while. Since the last time I posted here, I switched jobs, and moved countries, so it would be fair to say that I have been quite busy in the meanwhile. But I’d still like to apologise, and I promise I will try to post more frequently from now on.</p>
<p>If you have been here before, you might have noticed that things have changed a fair bit. This is the new blog, reborn from the ashes, so to say. Though only because I felt like it was necessary to burn the old one. It’s now built using <a href="https://jaspervdj.be/hakyll/">Hakyll</a> instead of <a href="https://blog.getpelican.com">Pelican</a><span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Why switch, you ask? Shiny toys, that’s why.<br />
<br />
</span></span>, and it’s using <a href="https://edwardtufte.github.io/tufte-css/">Tufte CSS</a> instead of my homegrown Jinja2 templates and CSS. I spent much more time on setting this up than I care to admit. The upshot is, I have new CSS without having to rewrite all my custom templates from scratch, and get to use these neat stylesheets.</p>
<p>One of my major pains with my old setup was the setup required to just write something quickly, due to the fact that I was maintaining my own styles and sources in different repositories, and also because Python requirements are notoriously janky if you’re not careful. This new system is handled entirely by <a href="https://www.stackage.org">stack</a>, which makes things much easier.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">By the way, you can get the source of this blog <a href="https://github.com/sulami/sulami.github.io">over here</a>, if you want to steal some code, or just look at it.<br />
<br />
</span></span> Initial setup takes quite a while, because I have to compile a whole load of dependencies, but it’s a fully automatic setup.</p>
<p>I have to admit, I was tempted to just switch to Medium during this whole process. But now that I have figured out how to build this whole thing<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Read: get it to compile<br />
<br />
</span></span>, I am quite happy with the results. Because Hakyll, just like Pelican, uses Markdown as source to generate HTML, I could easily port over my old posts once the dust had settled.</p>]]></summary>
</entry>
<entry>
    <title>A Fuzzy Finder in Haskell</title>
    <link href="https://sulami.github.io/posts/a-fuzzy-finder-in-haskell/index.html" />
    <id>https://sulami.github.io/posts/a-fuzzy-finder-in-haskell/index.html</id>
    <published>2016-06-24T00:00:00Z</published>
    <updated>2016-06-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is a response to <em><a href="http://blog.amjith.com/fuzzyfinder-in-10-lines-of-python">FuzzyFinder - in 10 lines of Python</a></em>, which was posted to reddit yesterday.</p>
<p>Following the blogpost linked above, I decided to write my own fuzzy finder in Haskell, because that is the language I am currently learning, and think has great potential. It is also a more interesting <a href="https://github.com/sulami/spielwiese/tree/master/hEuler">exercise</a> than <a href="https://projecteuler.net/">Project Euler</a>.</p>
<p>Just in case you have not read the original post and do not know what a fuzzy finder is, it is a mechanism to filter and sort a list of strings by searching for substrings. It is often used in text editors like vim or Sublime Text, where you can just type in <em>“accmanba”</em> and they will open up <code>account_management_backend.py</code> for you. As you can see, it makes switching between more than two files in a project much easier and faster.</p>
<p>Amjith wrote his finder using regular expressions, which are part of the Python standard library and can be compiled to be reasonably fast very easily. Sadly, Haskell has no implementation of regular expressions in its standard library, and I did not want to use third-party ones just for this. But as it turns out, we do not even need them, because the task is so simple and Haskell’s string manipulation capabilities are incredible, so that we can solve this by implementing the search algorithm ourselves and still achieve good performance.</p>
<p>So, let us get on to some actual code. The most interesting part here is the matching algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">partOf ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Int</span>)
partOf _ []     r <span class="fu">=</span> (<span class="dt">False</span>, <span class="dv">0</span>)
partOf c (x<span class="fu">:</span>xs) r <span class="fu">|</span>    c <span class="fu">==</span> x <span class="fu">=</span> (<span class="dt">True</span>, r <span class="fu">+</span> <span class="dv">1</span>)
                  <span class="fu">|</span> otherwise <span class="fu">=</span> partOf c xs <span class="fu">$</span> r <span class="fu">+</span> <span class="dv">1</span>

<span class="ot">match ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> ([<span class="dt">Char</span>], [<span class="dt">Char</span>]) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, [<span class="dt">Int</span>])
match i s <span class="fu">=</span> match&#39; i (snd s) []
  <span class="kw">where</span>
<span class="ot">    match&#39; ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, [<span class="dt">Int</span>])
    match&#39; []     _ r <span class="fu">=</span> (<span class="dt">True</span>, r)
    match&#39; (x<span class="fu">:</span>xs) s r <span class="fu">|</span> fst check <span class="fu">=</span> match&#39; xs (drop used s) <span class="fu">$</span> r <span class="fu">++</span> [used]
                      <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">False</span>, r)
      <span class="kw">where</span>
        used <span class="fu">=</span> snd check
        check <span class="fu">=</span> partOf x s <span class="dv">0</span></code></pre></div>
<p>I know this is not really optimized for readability and especially not if you do not know Haskell, but stay with me, it is quite simple. Before we compare the input, we map all the possible solutions to lowercase and store them in a tuple like <code>(&quot;String&quot;, &quot;string&quot;)</code>. This way, we can compare against the lowercase version and return the properly capitalized one later on. All we do then is check for each possible solution if each character of the input string appears in order in the solution. If so, we add it to a list along with some data, specifically the position of the first match and the distance between the first and last matched character in the solution. This is the same Amjith did for sorting. All this data gets returned in a big list of tuples with both versions of the solutions and the match data. It is not pretty, but it works.</p>
<p>The one function the module actually exports is <code>fuzzyFinder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fuzzyFinder ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]]
fuzzyFinder input list <span class="fu">=</span> map fst <span class="fu">.</span> map snd <span class="fu">$</span> sort combo
  <span class="kw">where</span>
    combo <span class="fu">=</span> zip (zip ((map sum <span class="fu">.</span> map tail) scores) (map head scores)) matches
    scores <span class="fu">=</span> map snd <span class="fu">$</span> map (match input) matches
    matches <span class="fu">=</span> filter (fst <span class="fu">.</span> match input) <span class="fu">$</span> prepInput list</code></pre></div>
<p>All this function does is build the tuple list with the lowercase versions, toss it into the match function and filter out the correct versions from the matches that came back, ordering them by the match data in the same way Amjith did it. There are just a couple of extra lines that I omitted here because they are not important, but you can find the complete source on <a href="https://github.com/sulami/spielwiese/tree/master/hFuzzyFinder">Github</a>.</p>
<p>Now you might say, this cannot be fast, it is iterating through all this stuff and with big enough input it will take forever to present results. Let me show you this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readL ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
readL a <span class="fu">=</span> read <span class="fu">$</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot;]&quot;</span>

main <span class="fu">=</span> <span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
          <span class="kw">if</span> length args <span class="fu">==</span> <span class="dv">2</span> <span class="kw">then</span> <span class="kw">do</span>
            list <span class="ot">&lt;-</span> readFile <span class="fu">$</span> args <span class="fu">!!</span> <span class="dv">1</span>
            print <span class="fu">$</span> fuzzyFinder (args <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">$</span> readL list
          <span class="kw">else</span>
            putStrLn <span class="st">&quot;Wrong number of args&quot;</span></code></pre></div>
<p>This is a small program that takes two arguments, the query string and a file path of a list of possible solutions and performs the actions outlined above. Using a 2.2GHz Core 2 Duo, because I am using my laptop, and a 46K list containing over 5000 words (Thanks, Project Euler), this happens:</p>
<pre><code>λ time ./interactive roro ../hEuler/022.input
[&quot;ROBERTO&quot;,&quot;RODRIGO&quot;,&quot;ROSARIO&quot;,&quot;GREGORIO&quot;,&quot;RIGOBERTO&quot;]
./interactive roro ../hEuler/022.input  0.08s user 0.00s system 96% cpu 0.079 total</code></pre>
<p>The execution time goes up to 0.09 seconds when printing out really many names, but that is caused by the fact that we have to print out 100 lines or more to the console, which also takes time. But in my opinion, this is more than fast enough for auto-completion, which is the main use for fuzzy finders.</p>
<p>So overall, I am really happy with how this turned out. I was able to write this on one morning despite still learning the language. It is reasonably concise despite the fact that I did not use regular expressions but searched the strings manually and also quite fast.</p>]]></summary>
</entry>
<entry>
    <title>Staying Healthy as a Programmer</title>
    <link href="https://sulami.github.io/posts/staying-healthy-as-a-programmer/index.html" />
    <id>https://sulami.github.io/posts/staying-healthy-as-a-programmer/index.html</id>
    <published>2016-06-22T00:00:00Z</published>
    <updated>2016-06-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>Disclaimer</em> In this post I link to some specific products. These links serve as examples and are by no means direct reccomendations. Some of these are just the result of a quick web search. If you decide to buy stuff, do your research, figure out what exactly you need and choose a product based on that.</p>
<p>One of the most important things in your life is your health. As programmers, and other professionals who mainly work at a desk, staying healthy can be surprisingly difficult, even though sitting all day seems not particularly demanding. Some of this risks can be avoided by consciously changing habits, but often the right equipment can also play a big role. You really should not skimp when it comes to maintaining your health. I will discuss some free, and also some non-free ways that can help you with that.</p>
<h2 id="repetitive-strain-injury">Repetitive Strain Injury</h2>
<p>There are several big health risks that programmers are affected by. The first one is <a href="https://en.wikipedia.org/wiki/Repetitive_strain_injury">repetitive strain injury</a>, which can happen to anyone and can completely stop you from coding if it gets too bad. The easiest way of preventing RSI is the right setup. You want your desk to be at the right height, so your elbows are at a right angle. Depending on the keyboard, a wrist rest can also be helpful. As a rule of thumb, if your hands or arms start hurting after several minutes of continuous typing, there’s something wrong.</p>
<p>No matter what you do, doing things as unnatural as typing for long periods of time is harmful to your body, like almost anything. So make sure to take regular breaks, and also do some <a href="https://www.youtube.com/watch?v=nmwqBMLVsjE">stretches</a> for your hands and arms.</p>
<p>You can also try using alternative keyboard layouts, although this is quite a big step. I switched to using <a href="https://colemak.com/">colemak</a>, which is still relatively close to QWERTY, on all my machines early this year, and it has helped me tremendously, but it also took me about 10 weeks using it full-time to get back to my own typing speed, and regain muscle memory for vim. Another popular alternative is <a href="https://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard">dvorak</a>, which is more widely supported (read: on Windows without extra software), but radically differs from QWERTY.</p>
<p>If you want to go all out, there are also <a href="https://www.amazon.com/Microsoft-Natural-Ergonomic-Keyboard-4000/dp/B000A6PPOK/">various</a> <a href="https://ultimatehackingkeyboard.com/">kinds</a> <a href="https://www.kinesis-ergo.com/shop/freestyle2-for-pc-us/">of</a> <a href="https://ergodox-ez.com/collections/keyboards/products/ergodox-ez-keyboard">ergonomical</a> <a href="http://matias.ca/ergopro/pc/">keyboards</a>, which some people swear by. I haven’t had any personal experience with these, but I feel like being able to e.g. have your hands wider apart can make a big difference in your wrists, especially if you are typing for 6-8 hours a day.</p>
<h2 id="back-problems">Back problems</h2>
<p>Another problem many office workers have are posture and back problems, which can lead to chronic pain. Make sure your whole working environment is set up in a way that does not slowly kill you.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote"><img src="http://www.metrophysicaltherapy.com/files/2014/02/workstation_426x418.jpg" title="fig:" alt="Proper posture illustration" /><br />
<br />
</span></span></p>
<p>A relativaly cheap solution I value very much are <a href="https://www.amazon.com/AmazonBasics-Single-Monitor-Display-Mounting/dp/B00MIBN16O/">monitor arms</a>, which are key to get both your monitor high enough to not to have look down at it and also your desk low enough to not strain your elbows and wrists while typing. An added bonus is the free space under the monitor. I personally prefer the desk mounted ones for flexibility reasons, and they also allow you to run the cables behind them, but wall mounting is also an option that can come in handy.</p>
<p>Another big part of your setup is your chair. Many office chairs are bad for your posture and do not support your lower back properly, encouraging you to lounge instead of sitting upright. Good chairs can be very expensive, the <a href="http://www.kabseating.com/office/product.asp?product=204">KAB Executive</a> retails for way above $1000, but I’d go as far and say it is worth that. I do not believe in saving money when it comes to my health. Also it is going to last a decade or more without problems. But you might not have this kind of money to spend on a chair, which I also fully understand. All I want is to make you think about how you sit in your chair, especially for long periods of intense concentration.</p>
<p>Another option can be a standing desk. There are many different ways of doing things, <a href="https://www.amazon.com/Adjustable-Height-Stand-Up-Desk-Monitor/dp/B00LNEB9KW/">fixed height standing desks</a>, <a href="https://www.amazon.com/LUXOR-Standup-CF48-DW-Stand-Crank-Adjustable/dp/B00PU6H5MA/">manually variable desks</a> and of course also <a href="https://www.amazon.com/Electric-Stand-Up-Desk-Charcoal/dp/B00XLRJSAW/">electrically operated ones</a>. In addition to that, there are also <a href="https://www.amazon.com/32-Wide-Standing-Desktop-Desk/dp/B015RXUV3U/">mini add-on desks</a> that you place on an existing desk. Standing makes it easier to keep a proper posture (and also burns some additional calories), but standing all day long is also bad for your back, so the proper mix between sitting and standing is important.</p>
<p>There is one more point, and it is perhaps the most important one I have to make: whatever you do, as an office worker on a desk, it is extremely important to take regular breaks, get up (or sit down), stretch a bit, go for a short walk. I would reccomend intervals of at most once per hour, better twice. This is important for your cardiovascular system (i.e. your heart), and can also help you think. Regular exercise of any kind is also something everyone should do. Go to the gym, running or ride a bicyle. Do something that makes you sweat two or three times a week, and your overall quality of life will skyrocket.</p>]]></summary>
</entry>
<entry>
    <title>Emacs From a Vim Addict's Perspective</title>
    <link href="https://sulami.github.io/posts/emacs-from-a-vim-addicts-perspective/index.html" />
    <id>https://sulami.github.io/posts/emacs-from-a-vim-addicts-perspective/index.html</id>
    <published>2016-03-03T00:00:00Z</published>
    <updated>2016-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have been playing around in Emacs lately. Vim has been the core of my workflow for half a decade now, and I just cannot imagine going back to non-modal editing anymore. I will now explain, why I might just switch to emacs in the long-term.</p>
<p>If you compare Emacs and vim, you will see that vim’s modal philosophy is the clearly superiour one, but you will also find that vim is somewhat limited. It works quite well out of the box, and my current <code>.vimrc</code> is about 300 lines in size, most of that just setting options, defining shortcuts and loading plugins.</p>
<p>VimL tends to work for these things, but as soon as you start to change default behaviour and writing your own functions, it all falls apart. Vim does not know anything about its own state, there is no proper programmatical way to query it, and VimL as a language is extremely clunky and difficult to debug once you surpass simpe <code>set</code> statements. This shows for example in the built-in help, that consists of plain text files that display the default configuration.</p>
<p>Emacs on the other hand is pretty much just a Lisp interpreter with a simple text editor written in said Lisp running on top of it. Because the configuration is done on the same level that the editor itself is written on, in the same language, you can essentially completely replace all default behaviour, and emacs has a great framework to get the current state and configuration of the editor, because everything is just saved into variables. There is this funny quote about Emacs being a great operating system lacking a decent editor, and I find that it is pretty accurate.</p>
<p>Enter <a href="http://spacemacs.org/">Spacemacs</a>. Spacemacs is an Emacs distribution, meaning it is a prepackaged set of packages and configs that are supposed to more or less implement vim’s behaviour on the emacs platform and integrate well without having to write several thousand lines of Elisp yourself, which is what you might actually need, depending on how much of vim you want in Emacs.</p>
<p>Spacemacs got reccomended to me first by <a href="https://kritzcreek.github.io/">Kritzcreek</a> some time ago, and ever since I have been keeping an eye on it. I generally like to build my own configs and only stealing small parts from other people, but with default emacs being so different from the modal vim-like experience I want, it would take months to even come close to my vim setup. Spacemacs on the other hand comes with mostly sane defaults, and my overall custom config on top of its defaults is currently less that 100 lines of Elisp. I also want to mention <a href="http://blog.aaronbieber.com/">Aaron Bieber</a>’s <a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc">talk about evil-mode</a> for finally pushing me over the line and investing a weekend into learning enough emacs to be productive.</p>
<p>I am currently still in the progress of building my own emacs config from scratch, recreating the parts of Spacemacs I actually use, but I am not sure if I will ever get it to a point where it is even remotely as polished. Another factor of course is that I do not really want to waste too much time on this, and at least right now, Spacemacs does what I need it to do. In the end, you always have to think about if that extra bit of more custom behaviour is worth the time-investment to get it to work.</p>]]></summary>
</entry>
<entry>
    <title>Why You Need Fuzz Testing</title>
    <link href="https://sulami.github.io/posts/why-you-need-fuzz-testing/index.html" />
    <id>https://sulami.github.io/posts/why-you-need-fuzz-testing/index.html</id>
    <published>2016-02-23T00:00:00Z</published>
    <updated>2016-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Unittesting is an important part of building reliable software, although by far not the only one. But many programmers misunderstand the purpose of unittests. Classic unittests have two purposes: They force you to develop a spec and enforce it, and they can protect you against regression when refactoring or otherwise changing your code. Contrary to what some believe, they do not ensure correctness of your code.</p>
<p>Static unittests have one major flaw: The programmer has to write them. Any function working on a list is usually tested using some small examples and an empty list to make sure nothing breaks. This usually means you have to write 3-5 test cases per function to cover basic functionality. Not only is this a lot of work, it is also error-prone, because some cases are easily forgotten, especially because the programmer writing the tests for his code has a set of preconceived notions about how his code might be used.</p>
<p>But when writing any meaningful software, you usually have to deal with all kinds of data from outside, and a lot of that data is to be mistrusted. There might be changes in APIs, software errors somewhere else, or even a malicious attacker trying to breach your system, and all that data could look anything but the way you expect it to. This is why unittests should be used to employ a contract that the tested code has to follow, and fuzz testing can help you do just that.</p>
<p>Haskell with its amazing type system has a very nice way to do this. Have a look at this test:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">describe <span class="st">&quot;the finder&quot;</span> <span class="fu">$</span>
  it <span class="st">&quot;only returns proper superstrings of the search term&quot;</span> <span class="fu">$</span>
    forAll nonNull <span class="fu">$</span> \x <span class="ot">-&gt;</span> property <span class="fu">$</span>
      \y <span class="ot">-&gt;</span> <span class="kw">let</span> rv <span class="fu">=</span> finder x y
            <span class="kw">in</span> rv <span class="ot">`shouldBe`</span> filter (isSubsequenceOf x) rv</code></pre></div>
<p>This code is part of a fuzzy finder I am toying with, and it ensures that a basic fact about it is always true, the results should always be proper superstrings of the search term, and the search term in turn a proper substring of all results. I could write a bunch of test cases including input like <code>&quot;abcdef&quot;</code> or <code>&quot;123&quot;</code> and supply a list of possible results, then evaluate myself what the result should look like and just assert that the results are equal.</p>
<p>But that would not only result in a considerable increase in code, easily quadrupling the code above, it would also not cover all possibilities. Haskell’s type system ensures that the finder only gets used with strings and lists of strings, but strings can have many forms. Because all of the input is coming from the user, there might be punctuation in there, spaces, maybe escaped, maybe Unicode symbols, who knows. That is why I instruct the test suite to just generate random strings and lists of strings to use (see the <code>forAll nonNull</code>) and verify the property independently. This runs a default of 100 different sets of input, many of which are complicated messes of whitespace, backslashes and other special characters. If any of these break the test, the suite tells me which one, so I can find out what is the problem with a set of input and whether the contract I employed is incorrect, or the function tested does not follow the contract.</p>
<p>The current actual fuzzy finder uses six different property contracts that it needs to satisfy, each four to six lines in size. Testing all of these manually would lead to a gigantic test suite, and modifying the parameters of the input would be a huge hassle. With fuzz testing, I can just tweak the <code>nonNull</code> generator to use different rules to generate input, like limiting it to a certain character range or string length.</p>
<p>The bottom line here is, if your unittests are handwritten, you most likely cannot be sure your code is behaving in production. There is almost no way you can think of all the possible ways your code is going to be used, and even if you could, the amount of testing code would not be feasible.</p>]]></summary>
</entry>
<entry>
    <title>Why I Use Pomodoro</title>
    <link href="https://sulami.github.io/posts/why-i-use-pomodoro/index.html" />
    <id>https://sulami.github.io/posts/why-i-use-pomodoro/index.html</id>
    <published>2016-01-11T00:00:00Z</published>
    <updated>2016-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Almost every programmer knows what it means to get in the zone. That weird feeling you get at two in the morning while working on a side-project, when the the time flies by and suddenly all important features are done. Mastering the zone is a crucial element of maximizing your productivity, but it can also be quite difficult.</p>
<p>Because the being in the zone is a very fragile state, it is important to reduce the risk of falling out of it. That means both preventing interruptions by outside sources like coworkers (within reason) and playing your own <a href="http://mindingourway.com/not-yet-gods/">monkey brain</a> to stay focused by reducing the possible distractions, like closing all non-related windows/tabs.</p>
<p>These simple methods can work sometimes, but to <em>master</em> the zone and be able to reliably enter it almost at will, a more sophisticated solution is needed, a system. There are a great number of systems, and most of them are designed to dictate a structure for planning work, so they can help take the last bit of excess cognitive load off your mind, leaving you with just the next problem to solve to think about.</p>
<p>One of the more simple systems is <a href="http://pomodorotechnique.com/">Pomodoro</a>. Pomodoro in a nutshell is dividing work into relatively small tasks, spend 25 minute intervals working on these tasks and taking breaks in between. This approach forces you to focus on the task at hand, making it easier to get in the flow. It is also a rather simple system, you can read its Wikipedia page in two minutes and then start using it, and the overhead is very small, which is why I like using it for most of my coding.</p>
<p>If you have never used such a productivity system, I urge you to give Pomodoro a try, there is not really anything to lose, and possibly a lot to gain. You can also combine it relatively easily with larger-scale systems, like <a href="http://martinfowler.com/articles/newMethodology.html">Agile</a> or <a href="http://scrummethodology.com/">Scrum</a>.</p>]]></summary>
</entry>
<entry>
    <title>Data-Pipelines in Haskell</title>
    <link href="https://sulami.github.io/posts/data-pipelines-in-haskell/index.html" />
    <id>https://sulami.github.io/posts/data-pipelines-in-haskell/index.html</id>
    <published>2015-12-07T00:00:00Z</published>
    <updated>2015-12-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Today I was writing some code in Golang and thought about why Haskell feels so much more powerful and expressive. Then I had a revelation. Haskell follows the UNIX philosophy, focussing on small functions that do exactly one thing (at least good Haskell code does so). It also makes these functions easily combinable without leading to syntastic noise like parenthesis-mountains. So I thought I might just write a post highlighting that, which is what you are currently reading.</p>
<p>We are going to start at the very basics, assuming you have little to no prior knowledge about Haskell. Haskell uses the <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Lambda_calculus_and_programming_languages">lambda calculus</a> and just whitespace to declare function arguments. So a function call looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">2</span> <span class="dv">3</span> <span class="co">-- 2 + 3 = 5</span></code></pre></div>
<p>If one of your arguments is actually the return value of another function call with arguments, you will need to add parentheses to tell your compiler which arguments belong to which function call, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> (add <span class="dv">1</span> <span class="dv">3</span>) <span class="co">-- 5 + (1 + 3) = 9</span></code></pre></div>
<p>Haskell functions often take arguments in an order so that the last argument is often the “main” one that is being used, which plays nicely with the <code>$</code> operator that is part of Prelude, the part of the Haskell standard library that gets imported automatically. <code>$</code> has the type <code>(a -&gt; b) -&gt; a -&gt; b</code> which looks sort of pointless, but in practise you can use it to build function pipelines without having to use parentheses.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> <span class="fu">$</span> add <span class="dv">1</span> <span class="dv">3</span> <span class="co">-- 5 + (1 + 3) = 9</span></code></pre></div>
<p>Note that in this code, <code>add 5</code> is a function that takes one argument, because one is already supplied. Its type is <code>Int -&gt; Int</code> compared to the original <code>Int -&gt; Int -&gt; Int</code>. And because Haskell has easy function composition using the <code>.</code> operator (<code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>), we can chain several functions in front of a <code>$</code>, building a reverse data pipeline like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">5</span> <span class="fu">.</span> subtract <span class="dv">3</span> <span class="fu">.</span> times <span class="dv">2</span> <span class="fu">$</span> add <span class="dv">1</span> <span class="dv">3</span> <span class="co">-- (((1 + 3) * 2) - 3) + 5 = 10</span></code></pre></div>
<p>As you can see, the data flows from the right side to the left. But coming back to the UNIX philosophy, there are also data pipelines, pipes. But in shell-pipes, data flows from left to right, which might be more intuitive. Note that in the last explanation I had to reverse the order because of the subtraction. We can fix this quite easily by defining a new operator, the “reverse <code>$</code>”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
x <span class="fu">&amp;</span> f <span class="fu">=</span> f x</code></pre></div>
<p>Note that the type annotation is the same as the one of <code>$</code> with just the arguments reversed. This specific operator is already defined in many community-made packages. It allows us to mimic the shell-pipe very closely:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="dv">1</span> <span class="dv">3</span> <span class="fu">&amp;</span> times <span class="dv">2</span> <span class="fu">&amp;</span> subtract <span class="dv">3</span> <span class="fu">&amp;</span> add <span class="dv">5</span> <span class="co">-- (((1 + 3) * 2) - 3) + 5 = 10</span></code></pre></div>
<p>Now the explanation looks just like the code, and data flows from left to right, just like in the shell. These data pipelines make it easy to let small functions like <code>words</code>, <code>lines</code> or <code>map</code> work on data and pass the results to the next function, without having to worry about memory management, buffer overflows or even types, which makes this more robust than a shell-oneliner while being just as expressive and simple. Haskell’s laziness even allows for simple parallelism like the shell does when piping data, where functions/programs start working as soon as the first data reaches them.</p>
<p>This concept is so great, there is even a huge library to do this while doing I/O like when accessing files or communicating over a network, <a href="https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview">Conduit</a>.</p>]]></summary>
</entry>
<entry>
    <title>Using Hoogle for Your Project</title>
    <link href="https://sulami.github.io/posts/using-hoogle-for-your-project/index.html" />
    <id>https://sulami.github.io/posts/using-hoogle-for-your-project/index.html</id>
    <published>2015-11-26T00:00:00Z</published>
    <updated>2015-11-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/ndmitchell/hoogle">Hoogle</a> is a fantastic tool that uses Haskell’s type system to build a searchable index of types, functions and constants, connecting with <a href="https://www.haskell.org/haddock/">Haddock</a> to provide documentation. It can be used to host browsable websites, like the <a href="https://www.haskell.org/hoogle/">Hackage instance</a> or the <a href="http://www.stackage.org/lts-3.15/hoogle">Stackage instance</a>, or used for editor integration, like in <a href="https://github.com/Twinside/vim-hoogle">vim</a> or <a href="https://github.com/haskell/haskell-mode">emacs</a>. Overall pretty great stuff.</p>
<p>But if working on your own project that is not online anywhere yet, setting up a local Hoogle instance is a bit tricky. But not anymore. I wrote a relatively simple shell script that sets up a local instance combining your project and the Stackage snapshot your project is using. It currently is quite naive, and assumes you are using Linux, and generally is a work in progress. But it works on my machine™, so I am <a href="https://github.com/sulami/dotfiles/blob/master/scripts/hoogle.sh">releasing it to the general public</a> (the link is to the master branch of my dotfiles, so it gets updated automatically).</p>
<p>Beware: There is no error checking whatsoever, so make sure you have GHC, Stack, Haddock and Hoogle installed and in your <code>$PATH</code> (also curl and awk). It might also eat all of your data. If you change your stack resolver, you need to delete the Stackage Hoogle database yourself to trigger a download of the right one, there is no version checking. Also local documentation paths do not work when using <code>hoogle server</code>. Some of this might get fixed in the future.</p>]]></summary>
</entry>
<entry>
    <title>Concurrent I/O in Haskell</title>
    <link href="https://sulami.github.io/posts/concurrent-io-in-haskell/index.html" />
    <id>https://sulami.github.io/posts/concurrent-io-in-haskell/index.html</id>
    <published>2015-09-11T00:00:00Z</published>
    <updated>2015-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Today just after waking up, I have been tweaking the last bits and bops of <a href="https://github.com/sulami/tinfoilsub">TinfoilSub</a>, a satiric fun/learning project of mine that scrapes YouTube channels to replicate a subscriptions page without requiring a Google account. The core of this little program is the <code>runServer</code> function that uses <a href="https://hackage.haskell.org/package/scotty">Scotty</a> to host a local page that displays the results, while the list of channels is read from a file. In the beginning, this function looked something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runServer ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runServer channels <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    videos <span class="ot">&lt;-</span> fmap (sort <span class="fu">.</span> concatMaybe) <span class="fu">.</span> liftIO <span class="fu">.</span> sequence <span class="fu">$</span>
                map scrapeChannel channels
    html <span class="fu">.</span> renderVideos <span class="fu">$</span> take <span class="dv">50</span> videos
  <span class="co">-- ... and more routes</span></code></pre></div>
<p>Now, imagine you have more than just a couple of channels in there. This works fine for 2-3 channels, but each channel adds about a second of runtime each time the page is refreshed and the channels are re-scraped, which quickly amounts to way to much. Naturally, I went on to profiling and trying to figure out how to improve the scaling capabilities, and one of the first things to come across is using several threads (duh). Pretty basic stuff, so lets add and import <code>Control.Parallel</code>, instruct the RTS to use a number of threads that suits the CPU in use and everything should be fine. Right?</p>
<p>This is the new code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runServer ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runServer channels <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    videos <span class="ot">&lt;-</span> fmap (sort <span class="fu">.</span> concatMaybe) <span class="fu">.</span> liftIO <span class="fu">.</span> sequence <span class="fu">$</span>
                parMap rpar scrapeChannel channels
    html <span class="fu">.</span> renderVideos <span class="fu">$</span> take <span class="dv">50</span> videos
  <span class="co">-- ... and more routes</span></code></pre></div>
<p>This looks neat and one might think it does what we want it to do. But looking at the actual performance when using 15 channels, this code is only about 20% faster, even when using 8 or more threads on a CPU with more than enough cores. Time for some more in depth analysis. The first thing I decided to look at was good old top. YouTube is not too slow in terms of respond times, so with a couple of threads one could assume we get to start scraping the page fairly early on, which results in increased CPU usage. But looking at top while refreshing the page revealed that the CPU was idling for a good 10 seconds before starting to scrape at all. Scraping was then run concurrently for the collected pages, so all cores were used and the actual scraping only took a second.</p>
<p>A look at Wireshark confirmed the problem. Wireshark recorded a new request to YouTube every second before scraping started. I looked around a bit in <a href="https://hackage.haskell.org/package/scalpel">Scalpel</a>, the scraping library I used and <a href="https://hackage.haskell.org/package/curl">the curl bindings</a> that were used for the actual requests, but nothing indicated any problems with making multiple requests at the same time.</p>
<p>So, now for the big reveal. For those who do not know, Haskell’s <code>Parallel</code> only works for pure parts of code, so no I/O, which hinders you from creating things like race conditions, deadlocks and other really bad stuff. That is a good thing. So, if you want to do concurrent (or parallel) I/O, you need to use <code>Concurrent</code>, which brings internal threads, thread communication tools and this kind of stuff. Now, this is all pretty dangerous territory in that with these tools, we can create the bad things mentioned above, which we do not want to risk, at least not if there are better alternatives. And as it turns out, there are. Use <a href="https://hackage.haskell.org/package/async">async</a>. Async is essentially a wrapper around all the evil stuff that makes it harder to shoot yourself in the foot. For us, there is this neat function called <code>mapConcurrently</code>, which does exactly what we want. Do a <code>map</code>, do it concurrently, and do it with <code>IO</code>. So this is what we get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runServer ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runServer channels <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    videos <span class="ot">&lt;-</span> fmap (sort <span class="fu">.</span> concatMaybe) <span class="fu">.</span> liftIO <span class="fu">$</span>
                mapConcurrently scrapeChannel channels
    html <span class="fu">.</span> renderVideos <span class="fu">$</span> take <span class="dv">50</span> videos
  <span class="co">-- ... and more routes</span></code></pre></div>
<p>And it does exactly what we want, it starts scraping as soon as the first request has returned a page for use, which reduces the runtime by more than half.</p>]]></summary>
</entry>
<entry>
    <title>Windows 10 - Post-Launch Thoughts</title>
    <link href="https://sulami.github.io/posts/windows-10-post-launch-thoughts/index.html" />
    <id>https://sulami.github.io/posts/windows-10-post-launch-thoughts/index.html</id>
    <published>2015-08-13T00:00:00Z</published>
    <updated>2015-08-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>So it has been two weeks since the official Windows 10 launch, and there have been a lot of discussions about it. I am going to summarize some of my own thoughts, now that I had the chance to test it myself.</p>
<p>Windows 10 is the newest and <a href="http://www.theguardian.com/technology/2015/may/11/windows-10-last-version-microsoft">supposedly last version</a> of the ever so popular operating system. <a href="%7Bfilename%7D/thoughts-on-windows-10-and-free-software.md">I have written before</a> about my concerns regarding the continuing vendor lock-in, especially DirectX, so I will try to not repeat myself.</p>
<p>From an end-user perspective, Windows 10 definitely feels better than Windows 8, which was crippled by design, due to the focus on the Metro view. Windows 10 brings back the “Start” menu, which I very much appreciate. The desktop in and of itself feels okay-ish, but <a href="https://imgur.com/a/ekRHU">lacks consistency in terms of UI style</a>. It certainly feels unfinished, not only visually, but also technically. On the test machine used, an all-in-one Dell with some 2.5 GHz quad core and 12 GB of memory, almost every window opened was white for roughly a second before it loaded, which makes the whole system feel really unresponsive and unpolished.</p>
<p>But let us get to the real topic of discussion here, the obvious surveillance “features”. When Windows 10 launched, people saw the new installer for the first time. The installer proudly promoted an “Express Installation” and almost tried to hide the manual configuration, <a href="https://jonathan.porta.codes/2015/07/30/windows-10-seems-to-have-some-scary-privacy-defaults/">which almost exclusively contained privacy-related options</a> that were all defaulting to invading your personal space. I myself have written up <a href="https://gist.github.com/sulami/7e74e3de7db372d38402">a small satirical piece</a> about it. Despite the majority of these options being hidden away, especially after the installation, there are some options you cannot even deactivate at all, like the <a href="http://cdn.ghacks.net/wp-content/uploads/2015/07/telemetry.jpg">automatic transmission of “diagnostic and usage data”</a> (assuming you do not use Enterprise Edition).</p>
<p>Yesterday, a Czech analyst found out that <a href="https://translate.google.com/translate?hl=en&amp;sl=cs&amp;tl=en&amp;u=http%3A%2F%2Faeronet.cz%2Fnews%2Fanalyza-windows-10-ve-svem-principu-jde-o-pouhy-terminal-na-sber-informaci-o-uzivateli-jeho-prstech-ocich-a-hlasu%2F">Windows 10 sends its keylogger logs home regularly</a>, as well as scraping your drives after you search for movie names (what might be the thought behind this, hmmm…), sending some 35 MB of encrypted data after using the webcam for the first time (hmmm, again), and of course sending voice data, even when deactivating Cortana entirely. The voice data alone makes up about 80 MB every 15 minutes.</p>
<p>There have also been <a href="http://arstechnica.co.uk/information-technology/2015/08/even-when-told-not-to-windows-10-just-cant-stop-talking-to-microsoft/">reports</a>, that these calls home are hardcoded in such a way, that you cannot use the (internal) firewall to block them, and they might leak your IP and other sensitive data if you are using a VPN or Tor.</p>
<p>In the end, while I have no particular desire to use Windows at all, with this developments, I do not know if I even feel save around a Windows 10 machine anymore, let alone using one. Sadly, the average user out there does not know anything about this (I imagine), and they will be the ones violated. This is a nightmare, and I desperately hope that Windows 10 will not catch on. Microsoft has shown its true nature, its endgame, and it is bad. I do not think, anyone can trust them anymore, at all.</p>]]></summary>
</entry>

</feed>
